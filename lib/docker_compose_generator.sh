#!/bin/bash
# lib/docker_compose_generator.sh
#
# Docker Compose Configuration Generator (v4.1 Heredoc-Based)
# Generates docker-compose.yml dynamically via heredoc (no static files)
#
# Features:
# - Full docker-compose.yml generation via heredoc
# - Dynamic port management for nginx reverse proxy
# - Integration with lib/docker_compose_manager.sh
# - PRD v4.1 compliant (no templates, all heredoc)
#
# Version: 4.2.0
# Author: VLESS Development Team
# Date: 2025-10-17

set -euo pipefail

# Configuration
VLESS_DIR="${VLESS_DIR:-/opt/vless}"
DOCKER_COMPOSE_FILE="${VLESS_DIR}/docker-compose.yml"
DOCKER_SUBNET="${DOCKER_SUBNET:-172.20.0.0/16}"
VLESS_PORT="${VLESS_PORT:-443}"

# Logging
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] [docker-compose-gen] $*" >&2
}

log_error() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] [docker-compose-gen] ERROR: $*" >&2
}

# =============================================================================
# Function: generate_docker_compose
# Description: Generates complete docker-compose.yml via heredoc
#
# Parameters:
#   $@ - nginx_ports: Array of ports for nginx reverse proxy (e.g., 8443 8444)
#        Empty array = no ports exposed (reverse proxy not configured)
#
# Returns:
#   0 on success, 1 on failure
#
# Output:
#   Creates /opt/vless/docker-compose.yml
#
# Example:
#   generate_docker_compose 8443 8444 8445
# =============================================================================
generate_docker_compose() {
    local nginx_ports=("$@")

    log "Generating docker-compose.yml (heredoc-based, v4.1)"
    log "  VLESS Port: ${VLESS_PORT}"
    log "  Docker Subnet: ${DOCKER_SUBNET}"
    log "  Nginx Ports: ${nginx_ports[*]:-none}"

    # Create backup if file exists
    if [ -f "${DOCKER_COMPOSE_FILE}" ]; then
        cp "${DOCKER_COMPOSE_FILE}" "${DOCKER_COMPOSE_FILE}.bak"
        log "  Backup created: ${DOCKER_COMPOSE_FILE}.bak"
    fi

    # Generate nginx ports section
    local nginx_ports_yaml=""
    if [ ${#nginx_ports[@]} -gt 0 ]; then
        for port in "${nginx_ports[@]}"; do
            nginx_ports_yaml+="      - \"${port}:${port}\"\n"
        done
    else
        # Empty ports array (reverse proxy not configured)
        nginx_ports_yaml="[]  # Empty by default - populated dynamically"
    fi

    # Generate docker-compose.yml via heredoc
    cat > "${DOCKER_COMPOSE_FILE}" <<EOF
version: '3.8'

services:
  # ===========================================================================
  # Xray-core Service (VLESS Reality + HTTP Proxy Inbounds)
  # ===========================================================================
  xray:
    image: teddysun/xray:24.11.30
    container_name: vless_xray
    restart: unless-stopped
    user: nobody
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    volumes:
      - ${VLESS_DIR}/config/config.json:/etc/xray/config.json:ro
      - ${VLESS_DIR}/logs/xray/:/var/log/xray/
      - /etc/letsencrypt:/etc/letsencrypt:ro
    ports:
      - "${VLESS_PORT}:443"
    networks:
      - vless_reality_net
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # ===========================================================================
  # stunnel Service (TLS Termination for SOCKS5/HTTP Proxy)
  # v4.0+ feature: Separate TLS layer from proxy logic
  # ===========================================================================
  stunnel:
    image: dweomer/stunnel:latest
    container_name: vless_stunnel
    restart: unless-stopped
    volumes:
      - ${VLESS_DIR}/config/stunnel.conf:/etc/stunnel/stunnel.conf:ro
      - /etc/letsencrypt:/etc/letsencrypt:ro
      - ${VLESS_DIR}/logs/stunnel/:/var/log/stunnel/
    ports:
      - "1080:1080"  # SOCKS5 proxy (TLS 1.3)
      - "8118:8118"  # HTTP proxy (TLS 1.3)
    networks:
      - vless_reality_net
    depends_on:
      - xray
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # ===========================================================================
  # Nginx Reverse Proxy Service (v4.2 NEW)
  # Site-Specific Reverse Proxy for Blocked Websites
  # ===========================================================================
  nginx:
    image: nginx:alpine
    container_name: vless_nginx_reverseproxy
    restart: unless-stopped
    user: nginx
    volumes:
      # Main reverse proxy configs (generated by lib/nginx_config_generator.sh)
      - ${VLESS_DIR}/config/reverse-proxy/:/etc/nginx/conf.d/reverse-proxy/:ro

      # HTTP context config (rate limiting, fail2ban log format)
      - ${VLESS_DIR}/config/reverse-proxy-http-context.conf:/etc/nginx/conf.d/reverse-proxy-http-context.conf:ro

      # Let's Encrypt certificates (read-only)
      - /etc/letsencrypt:/etc/letsencrypt:ro

      # Logs for fail2ban monitoring
      - ${VLESS_DIR}/logs/nginx/:/var/log/nginx/

    # Port mappings: Managed dynamically via lib/docker_compose_manager.sh
    # Ports are added when creating reverse proxy (vless-setup-proxy)
    # Ports are removed when deleting reverse proxy (vless-proxy remove)
    ports: ${nginx_ports_yaml}

    networks:
      - vless_reality_net

    depends_on:
      - xray

    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

    # Health check
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

  # ===========================================================================
  # Nginx Fake Site Service (VLESS Reality Fallback)
  # Shows legitimate website for invalid VLESS connections
  # ===========================================================================
  fake-site:
    image: nginx:alpine
    container_name: vless_fake_site
    restart: unless-stopped
    user: nginx
    volumes:
      - ${VLESS_DIR}/fake-site/:/etc/nginx/conf.d/:ro
      - ${VLESS_DIR}/logs/fake-site/:/var/log/nginx/
    networks:
      - vless_reality_net
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

# =============================================================================
# Networks
# =============================================================================
networks:
  vless_reality_net:
    name: vless_reality_net
    driver: bridge
    ipam:
      config:
        - subnet: ${DOCKER_SUBNET}
EOF

    local exit_code=$?

    if [ $exit_code -eq 0 ]; then
        log "✅ docker-compose.yml generated successfully"
        log "  Location: ${DOCKER_COMPOSE_FILE}"
        return 0
    else
        log_error "❌ Failed to generate docker-compose.yml"

        # Restore backup if generation failed
        if [ -f "${DOCKER_COMPOSE_FILE}.bak" ]; then
            mv "${DOCKER_COMPOSE_FILE}.bak" "${DOCKER_COMPOSE_FILE}"
            log "  Backup restored"
        fi

        return 1
    fi
}

# =============================================================================
# Function: validate_docker_compose
# Description: Validates generated docker-compose.yml
#
# Returns:
#   0 if valid, 1 if invalid
# =============================================================================
validate_docker_compose() {
    log "Validating docker-compose.yml..."

    if [ ! -f "${DOCKER_COMPOSE_FILE}" ]; then
        log_error "docker-compose.yml not found: ${DOCKER_COMPOSE_FILE}"
        return 1
    fi

    # Validate YAML syntax
    if command -v docker-compose &> /dev/null; then
        if docker-compose -f "${DOCKER_COMPOSE_FILE}" config > /dev/null 2>&1; then
            log "✅ docker-compose.yml is valid"
            return 0
        else
            log_error "❌ docker-compose.yml has syntax errors"
            docker-compose -f "${DOCKER_COMPOSE_FILE}" config 2>&1 | head -10
            return 1
        fi
    elif command -v docker &> /dev/null && docker compose version &> /dev/null; then
        if docker compose -f "${DOCKER_COMPOSE_FILE}" config > /dev/null 2>&1; then
            log "✅ docker-compose.yml is valid"
            return 0
        else
            log_error "❌ docker-compose.yml has syntax errors"
            docker compose -f "${DOCKER_COMPOSE_FILE}" config 2>&1 | head -10
            return 1
        fi
    else
        log "⚠️  Warning: docker-compose not found, skipping validation"
        return 0
    fi
}

# =============================================================================
# Function: get_current_nginx_ports
# Description: Extracts current nginx ports from docker-compose.yml
#
# Returns:
#   Array of ports (one per line) to stdout
# =============================================================================
get_current_nginx_ports() {
    if [ ! -f "${DOCKER_COMPOSE_FILE}" ]; then
        return 0
    fi

    # Extract ports from nginx service using grep/sed
    # Format: - "8443:8443" → 8443
    grep -A 20 "^  nginx:" "${DOCKER_COMPOSE_FILE}" \
        | grep -E '^\s+- "[0-9]+:[0-9]+"' \
        | sed -E 's/.*"([0-9]+):[0-9]+".*/\1/' \
        || true
}

# =============================================================================
# Main execution (for testing)
# =============================================================================
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # Script is being executed directly (not sourced)

    if [ $# -lt 1 ]; then
        echo "Usage: $0 <command> [options]"
        echo ""
        echo "Commands:"
        echo "  generate [PORT1 PORT2 ...]  - Generate docker-compose.yml with nginx ports"
        echo "  validate                     - Validate existing docker-compose.yml"
        echo "  get-ports                    - Show current nginx ports"
        echo ""
        echo "Examples:"
        echo "  $0 generate                 # No nginx ports (reverse proxy not configured)"
        echo "  $0 generate 8443 8444       # With 2 nginx ports"
        echo "  $0 validate                 # Validate syntax"
        echo "  $0 get-ports                # List current ports"
        exit 1
    fi

    command="$1"
    shift

    case "$command" in
        generate)
            generate_docker_compose "$@" && validate_docker_compose
            ;;
        validate)
            validate_docker_compose
            ;;
        get-ports)
            get_current_nginx_ports
            ;;
        *)
            log_error "Unknown command: $command"
            exit 1
            ;;
    esac
fi
