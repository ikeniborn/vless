#!/bin/bash
# cli/vless-setup-proxy
#
# VLESS v5.15 - Interactive Reverse Proxy Setup Wizard
# Guides user through complete reverse proxy configuration
#
# Features:
# - Domain validation (DNS mandatory via validate_dns_for_domain)
# - Certificate acquisition (unified workflow via acquire_certificate_for_domain)
# - Nginx config generation (security-hardened, localhost-only)
# - fail2ban multi-port protection
# - HAProxy SNI routing (NO UFW port opening required)
# - Subdomain-based access: https://domain (NO port number!)
# - v5.10: Advanced options wizard (OAuth2, WebSocket, CSP)
# - v5.11: Enhanced security headers (COOP, COEP, CORP, Expect-CT)
# - v5.14: Comprehensive pre-flight checks (CRITICAL BEFORE INSTALLATION)
#   * Docker containers status (HAProxy, Nginx)
#   * Disk space validation (100MB minimum)
#   * Proxy limit enforcement (10 slots max)
#   * Port availability (database, nginx, docker-compose, system)
#   * Domain uniqueness verification
#   * Cloudflare Bot Management detection (4 methods)
#   * Target site reachability check
# - v5.15: Enhanced pre-flight checks (4 NEW CHECKS)
#   * DNS pre-validation (A/AAAA records, IP verification)
#   * fail2ban status check (brute-force protection awareness)
#   * Rate limit zone validation (nginx crash loop prevention + auto-fix)
#   * HAProxy config syntax validation (prevent startup failures)
#
# Version: 5.15.0
# Author: VLESS Development Team
# Date: 2025-10-21

set -euo pipefail

# =============================================================================
# Configuration
# =============================================================================

INSTALL_PATH="/opt/vless"
LIB_PATH="${INSTALL_PATH}/lib"

# =============================================================================
# Colors & Formatting (defined BEFORE sourcing to avoid readonly conflicts)
# =============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'
BOLD='\033[1m'

# Source library files
source "${LIB_PATH}/certificate_manager.sh"     # v4.3: DNS validation + unified cert acquisition
source "${LIB_PATH}/haproxy_config_manager.sh"  # v4.3: HAProxy dynamic routing
source "${LIB_PATH}/nginx_config_generator.sh"
# source "${LIB_PATH}/xray_http_inbound.sh"  # v5.3: Deprecated - nginx proxies directly to target
source "${LIB_PATH}/letsencrypt_integration.sh"
source "${LIB_PATH}/fail2ban_config.sh"
source "${LIB_PATH}/reverseproxy_db.sh"
source "${LIB_PATH}/docker_compose_manager.sh"

# Icons
ICON_INFO="ℹ️"
ICON_SUCCESS="✅"
ICON_WARNING="⚠️"
ICON_ERROR="❌"
ICON_ROCKET="🚀"
ICON_LOCK="🔒"
ICON_GLOBE="🌐"
ICON_KEY="🔑"

# =============================================================================
# Helper Functions
# =============================================================================

print_header() {
    echo "" >&2
    echo -e "${CYAN}${BOLD}═══════════════════════════════════════════════════════════════${NC}" >&2
    echo -e "${CYAN}${BOLD}  $1${NC}" >&2
    echo -e "${CYAN}${BOLD}═══════════════════════════════════════════════════════════════${NC}" >&2
    echo "" >&2
}

print_step() {
    echo -e "${BLUE}${BOLD}▶ $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}${ICON_SUCCESS} $1${NC}" >&2
}

print_error() {
    echo -e "${RED}${ICON_ERROR} $1${NC}" >&2
}

print_warning() {
    echo -e "${YELLOW}${ICON_WARNING} $1${NC}" >&2
}

print_info() {
    echo -e "${CYAN}${ICON_INFO} $1${NC}" >&2
}

# =============================================================================
# Validation Functions
# =============================================================================

validate_domain() {
    local domain="$1"

    # Basic regex validation
    if ! [[ "$domain" =~ ^[a-zA-Z0-9][a-zA-Z0-9.-]+[a-zA-Z0-9]$ ]]; then
        return 1
    fi

    # Length check
    if [ ${#domain} -lt 4 ] || [ ${#domain} -gt 253 ]; then
        return 1
    fi

    return 0
}

check_dns_resolution() {
    local domain="$1"
    local server_ip

    print_step "Проверка DNS резолюции для $domain..."

    # Get server's public IP
    server_ip=$(curl -s https://api.ipify.org 2>/dev/null || curl -s https://ifconfig.me 2>/dev/null || echo "")

    if [[ -z "$server_ip" ]]; then
        print_error "Не удалось определить публичный IP сервера"
        return 1
    fi

    print_info "Публичный IP сервера: $server_ip"

    # Resolve domain
    local domain_ip
    domain_ip=$(dig +short "$domain" @8.8.8.8 2>/dev/null | tail -1)

    if [[ -z "$domain_ip" ]]; then
        print_error "Домен $domain не резолвится"
        print_warning "Убедитесь, что создана A-запись, указывающая на $server_ip"
        return 1
    fi

    print_info "Домен резолвится в: $domain_ip"

    # Check if IPs match
    if [[ "$domain_ip" != "$server_ip" ]]; then
        print_error "DNS запись не указывает на этот сервер"
        print_error "  Ожидается: $server_ip"
        print_error "  Получено:  $domain_ip"
        print_warning "Обновите A-запись для $domain → $server_ip"
        return 1
    fi

    print_success "DNS резолюция корректна"
    return 0
}

validate_target_site() {
    local target="$1"

    print_step "Валидация целевого сайта: $target..."

    # Check reachability
    if ! curl -s -I --max-time 10 "https://${target}" > /dev/null 2>&1; then
        print_error "Целевой сайт недоступен: https://${target}"
        return 1
    fi

    # Check TLS 1.3 support
    if ! curl -sI --tlsv1.3 --tls-max 1.3 --max-time 10 "https://${target}" > /dev/null 2>&1; then
        print_warning "Целевой сайт не поддерживает TLS 1.3"
        print_warning "Это может снизить совместимость, но не критично"
    fi

    print_success "Целевой сайт валиден и доступен"
    return 0
}

check_port_available() {
    local port="$1"

    if sudo ss -tulnp | grep -q ":${port} "; then
        print_error "Порт $port уже занят"
        sudo ss -tulnp | grep ":${port} "
        return 1
    fi

    print_success "Порт $port доступен"
    return 0
}

# =============================================================================
# Interactive Input Functions
# =============================================================================

prompt_domain() {
    local domain

    print_header "Шаг 1: Домен для Reverse Proxy"

    echo -e "${CYAN}Введите домен для reverse proxy (например, proxy.example.com):${NC}" >&2
    echo -e "${YELLOW}Требования:${NC}" >&2
    echo "  - Домен должен указывать на IP этого сервера (A-запись)" >&2
    echo "  - Будет автоматически получен Let's Encrypt сертификат" >&2
    echo "" >&2

    while true; do
        read -p "Домен: " domain

        if ! validate_domain "$domain"; then
            print_error "Некорректный формат домена"
            continue
        fi

        # Check if domain already exists
        if get_proxy "$domain" > /dev/null 2>&1; then
            print_error "Reverse proxy для домена $domain уже существует"
            echo "" >&2
            read -p "Хотите посмотреть существующую конфигурацию? [y/N]: " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                sudo vless-proxy show "$domain"
            fi
            continue
        fi

        # Check DNS
        if ! check_dns_resolution "$domain"; then
            echo "" >&2
            read -p "Продолжить несмотря на DNS ошибку? [y/N]: " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                continue
            fi
        fi

        break
    done

    echo "$domain"
}

prompt_target_site() {
    local target

    print_header "Шаг 2: Целевой Сайт (Проксируемый)"

    echo -e "${CYAN}Введите целевой сайт для проксирования (например, blocked-site.com):${NC}" >&2
    echo -e "${YELLOW}Что это:${NC}" >&2
    echo "  - Сайт, к которому нужен доступ через прокси" >&2
    echo "  - Все запросы будут перенаправлены на этот домен" >&2
    echo "  - Запросы на другие домены будут заблокированы (безопасность)" >&2
    echo "" >&2

    while true; do
        read -p "Целевой сайт: " target

        if ! validate_domain "$target"; then
            print_error "Некорректный формат домена"
            continue
        fi

        if ! validate_target_site "$target"; then
            echo "" >&2
            read -p "Продолжить несмотря на ошибку валидации? [y/N]: " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                continue
            fi
        fi

        break
    done

    echo "$target"
}

prompt_port() {
    local port
    local proxy_count

    print_header "Шаг 3: Nginx Backend Port (localhost-only)"

    proxy_count=$(get_proxy_count)

    echo -e "${CYAN}Выберите localhost-only порт для nginx backend:${NC}" >&2
    echo -e "${YELLOW}Доступные порты: 9443-9452 (всего 10 слотов)${NC}" >&2
    echo "  Использовано: $proxy_count/10" >&2
    echo "" >&2
    echo -e "${CYAN}${ICON_INFO} v4.3 HAProxy Architecture:${NC}" >&2
    echo "  - Nginx слушает на 127.0.0.1:<port> (localhost-only)" >&2
    echo "  - HAProxy маршрутизирует по SNI с порта 443" >&2
    echo "  - Публичный доступ: https://<domain> (БЕЗ номера порта!)" >&2
    echo "" >&2

    # Auto-suggest next available port (v4.3)
    local suggested_port
    if suggested_port=$(get_next_available_port 2>/dev/null); then
        echo -e "${GREEN}Рекомендуется (авто-выбор): $suggested_port${NC}" >&2
    else
        # Fallback if get_next_available_port fails
        suggested_port=$((9443 + proxy_count))
        echo -e "${YELLOW}Рекомендуется: $suggested_port${NC}" >&2
    fi

    echo "" >&2

    while true; do
        read -p "Порт [$suggested_port]: " port
        port=${port:-$suggested_port}

        # Validate port range (v4.3: 9443-9452)
        if [ "$port" -lt 9443 ] || [ "$port" -gt 9452 ]; then
            print_error "Порт должен быть в диапазоне 9443-9452"
            continue
        fi

        # Check if port is already occupied (database + nginx configs)
        # v5.8: Enhanced port detection - checks both DB and nginx configs to prevent conflicts
        local config_dir="/opt/vless/config/reverse-proxy"
        local db_file="/opt/vless/config/reverse_proxies.json"

        # Collect used ports from database
        local db_ports=""
        if [[ -f "$db_file" ]]; then
            db_ports=$(jq -r '.proxies[].port' "$db_file" 2>/dev/null | sort -n)
        fi

        # Collect used ports from nginx configs
        local nginx_ports=""
        if [[ -d "$config_dir" ]]; then
            nginx_ports=$(grep -h "listen.*:" "$config_dir"/*.conf 2>/dev/null | \
                          grep -oP 'listen\s+[\d.]+:\K\d+' | \
                          sort -n | uniq)
        fi

        # Merge both lists
        local all_ports=$(echo -e "${db_ports}\n${nginx_ports}" | sort -n | uniq | grep -v '^$')

        # Check if port is occupied
        if echo "$all_ports" | grep -q "^${port}$"; then
            print_error "Порт $port уже занят другим reverse proxy"
            print_info "Используйте команду: sudo vless-proxy list"
            continue
        fi

        break
    done

    echo "$port"
}

prompt_letsencrypt_email() {
    local email

    print_header "Шаг 4: Let's Encrypt Email"

    echo -e "${CYAN}Введите email для уведомлений Let's Encrypt:${NC}" >&2
    echo -e "${YELLOW}Для чего:${NC}" >&2
    echo "  - Уведомления об истечении сертификата" >&2
    echo "  - Критические безопасности обновления" >&2
    echo "  - Email НЕ публикуется, остаётся приватным" >&2
    echo "" >&2

    while true; do
        read -p "Email: " email

        # Basic email validation
        if ! [[ "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
            print_error "Некорректный формат email"
            continue
        fi

        break
    done

    echo "$email"
}

prompt_advanced_options() {
    print_header "Шаг 5: Дополнительные Опции (v5.11)"

    echo -e "${CYAN}Настройте дополнительные функции для вашего reverse proxy:${NC}" >&2
    echo "" >&2

    # OAuth2 Support
    echo -e "${YELLOW}1. OAuth2 / Large Cookie Support${NC}" >&2
    echo "   Для сайтов с OAuth2, Google Auth, или большими cookies (>4kb)" >&2
    echo "   Увеличивает буферы: 32k/16x32k/64k" >&2
    read -p "   Включить OAuth2 support? [Y/n]: " -n 1 -r oauth2_choice
    echo
    if [[ $oauth2_choice =~ ^[Nn]$ ]]; then
        export OAUTH2_SUPPORT="false"
    else
        export OAUTH2_SUPPORT="true"
    fi
    echo "" >&2

    # WebSocket Support
    echo -e "${YELLOW}2. WebSocket Support${NC}" >&2
    echo "   Для real-time приложений (chat, dashboards, collaborative editing)" >&2
    echo "   Увеличивает timeouts: 3600s (1 hour)" >&2
    read -p "   Включить WebSocket support? [Y/n]: " -n 1 -r websocket_choice
    echo
    if [[ $websocket_choice =~ ^[Nn]$ ]]; then
        export ENABLE_WEBSOCKET="false"
    else
        export ENABLE_WEBSOCKET="true"
    fi
    echo "" >&2

    # CSP Header Handling
    echo -e "${YELLOW}3. Content Security Policy (CSP) Headers${NC}" >&2
    echo "   CSP от целевого сайта может блокировать ресурсы через прокси-домен" >&2
    echo "   Опции:" >&2
    echo "     - Strip (рекомендуется): Удалить CSP headers для совместимости" >&2
    echo "     - Keep: Сохранить CSP (может не работать с некоторыми сайтами)" >&2
    read -p "   Strip CSP headers? [Y/n]: " -n 1 -r csp_choice
    echo
    if [[ $csp_choice =~ ^[Nn]$ ]]; then
        export STRIP_CSP="false"
    else
        export STRIP_CSP="true"
    fi
    echo "" >&2

    # Enhanced Security Headers (v5.11)
    echo -e "${YELLOW}4. Enhanced Security Headers (v5.11)${NC}" >&2
    echo "   Современные заголовки безопасности (COOP, COEP, CORP, Expect-CT)" >&2
    echo "   Улучшают browser isolation и защиту от атак" >&2
    echo "   ${RED}ВНИМАНИЕ:${NC} Может не работать с сайтами, использующими cross-origin ресурсы" >&2
    echo "   Рекомендуется: OFF для большинства сайтов" >&2
    read -p "   Включить Enhanced Security Headers? [y/N]: " -n 1 -r security_choice
    echo
    if [[ $security_choice =~ ^[Yy]$ ]]; then
        export ENHANCED_SECURITY_HEADERS="true"
    else
        export ENHANCED_SECURITY_HEADERS="false"
    fi
    echo "" >&2

    # Custom User-Agent (v5.13)
    echo -e "${YELLOW}5. Custom User-Agent (v5.13)${NC}" >&2
    echo "   Некоторые сайты блокируют прокси запросы (Cloudflare защита)" >&2
    echo "   Пример: claude.ai, chatgpt.com требуют реалистичный User-Agent" >&2
    echo "   По умолчанию: Mozilla/5.0 Chrome (современный браузер)" >&2
    echo -e "   ${YELLOW}ПРИМЕЧАНИЕ:${NC} Для сайтов с Cloudflare Bot Management может не помочь" >&2
    read -p "   Изменить User-Agent? [y/N]: " -n 1 -r ua_choice
    echo
    if [[ $ua_choice =~ ^[Yy]$ ]]; then
        echo -n "   Введите User-Agent (или Enter для default): " >&2
        read -r custom_ua
        if [[ -n "$custom_ua" ]]; then
            export CUSTOM_USER_AGENT="$custom_ua"
        else
            export CUSTOM_USER_AGENT="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        fi
    else
        export CUSTOM_USER_AGENT="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    fi
    echo "" >&2

    # Summary
    print_info "Выбранные опции:"
    echo "  OAuth2 Support:          ${OAUTH2_SUPPORT}" >&2
    echo "  WebSocket Support:       ${ENABLE_WEBSOCKET}" >&2
    echo "  Strip CSP:               ${STRIP_CSP}" >&2
    echo "  Enhanced Security (NEW): ${ENHANCED_SECURITY_HEADERS}" >&2
    echo "  Custom User-Agent:       ${CUSTOM_USER_AGENT:0:50}..." >&2
    echo "" >&2
}

# =============================================================================
# Pre-flight Checks (v5.14)
# =============================================================================

check_proxy_limitations() {
    local domain="$1"
    local target="$2"
    local port="$3"

    local has_limitations=false
    local limitation_messages=()
    local warnings=()

    print_header "Проверка Ограничений (v5.14)"

    # Check 0: Docker containers status
    print_step "Проверка статуса Docker контейнеров..."

    local haproxy_status
    haproxy_status=$(docker ps --filter "name=vless_haproxy" --format "{{.Status}}" 2>/dev/null)

    if [ -z "$haproxy_status" ]; then
        limitation_messages+=("❌ КРИТИЧНО: HAProxy контейнер не запущен")
        limitation_messages+=("   Запустите VPN сервер: cd /opt/vless && docker compose up -d")
        has_limitations=true
    elif ! echo "$haproxy_status" | grep -q "Up"; then
        limitation_messages+=("❌ КРИТИЧНО: HAProxy контейнер не работает (статус: $haproxy_status)")
        limitation_messages+=("   Проверьте логи: docker logs vless_haproxy --tail 50")
        has_limitations=true
    else
        print_success "HAProxy контейнер работает"
    fi

    local nginx_status
    nginx_status=$(docker ps --filter "name=vless_nginx_reverseproxy" --format "{{.Status}}" 2>/dev/null)

    if [ -z "$nginx_status" ]; then
        limitation_messages+=("❌ КРИТИЧНО: Nginx Reverse Proxy контейнер не запущен")
        limitation_messages+=("   Запустите VPN сервер: cd /opt/vless && docker compose up -d")
        has_limitations=true
    elif ! echo "$nginx_status" | grep -q "Up"; then
        limitation_messages+=("❌ КРИТИЧНО: Nginx контейнер не работает (статус: $nginx_status)")
        limitation_messages+=("   Проверьте логи: docker logs vless_nginx_reverseproxy --tail 50")
        has_limitations=true
    else
        print_success "Nginx Reverse Proxy контейнер работает"
    fi

    # Check 1: Disk space
    print_step "Проверка свободного места..."

    local disk_free_mb
    disk_free_mb=$(df -BM /opt/vless | tail -1 | awk '{print $4}' | sed 's/M//')

    if [ "$disk_free_mb" -lt 100 ]; then
        limitation_messages+=("❌ КРИТИЧНО: Недостаточно места на диске (/opt/vless: ${disk_free_mb}MB)")
        limitation_messages+=("   Требуется минимум 100MB для сертификатов и логов")
        has_limitations=true
    elif [ "$disk_free_mb" -lt 500 ]; then
        warnings+=("⚠️  Мало свободного места: ${disk_free_mb}MB (рекомендуется >500MB)")
    else
        print_success "Свободно: ${disk_free_mb}MB"
    fi

    # Check 2: Maximum proxy limit (10 slots)
    print_step "Проверка лимита прокси..."

    local proxy_count
    proxy_count=$(get_proxy_count 2>/dev/null || echo "0")

    if [ "$proxy_count" -ge 10 ]; then
        limitation_messages+=("❌ КРИТИЧНО: Достигнут лимит прокси (10/10)")
        limitation_messages+=("   Необходимо удалить существующий прокси перед добавлением нового")
        limitation_messages+=("   Команда: sudo vless-proxy list")
        has_limitations=true
    elif [ "$proxy_count" -ge 8 ]; then
        warnings+=("⚠️  Осталось слотов: $((10 - proxy_count))/10")
    else
        print_success "Использовано слотов: $proxy_count/10"
    fi

    # Check 3: Port availability (comprehensive check)
    print_step "Проверка доступности порта $port..."

    local port_check_failed=false
    local port_check_details=()

    # Validate port range
    if [ "$port" -lt 9443 ] || [ "$port" -gt 9452 ]; then
        limitation_messages+=("❌ КРИТИЧНО: Порт $port вне допустимого диапазона")
        limitation_messages+=("   Допустимый диапазон: 9443-9452")
        has_limitations=true
        port_check_failed=true
    fi

    if [ "$port_check_failed" = false ]; then
        # Check in database
        if [ -f "/opt/vless/config/reverse_proxies.json" ]; then
            local db_ports
            db_ports=$(jq -r '.proxies[].port' /opt/vless/config/reverse_proxies.json 2>/dev/null | grep "^${port}$")
            if [ -n "$db_ports" ]; then
                port_check_failed=true
                local domain_using_port
                domain_using_port=$(jq -r ".proxies[] | select(.port == $port) | .domain" /opt/vless/config/reverse_proxies.json 2>/dev/null)
                port_check_details+=("   - База данных: порт занят доменом $domain_using_port")
            fi
        fi

        # Check in nginx configs
        if [ -d "/opt/vless/config/reverse-proxy" ]; then
            local nginx_config_with_port
            nginx_config_with_port=$(grep -l "listen.*:${port}" /opt/vless/config/reverse-proxy/*.conf 2>/dev/null | head -1)
            if [ -n "$nginx_config_with_port" ]; then
                port_check_failed=true
                port_check_details+=("   - Nginx config: порт занят в $(basename "$nginx_config_with_port")")
            fi
        fi

        # Check in docker-compose.yml
        if [ -f "/opt/vless/docker-compose.yml" ]; then
            local docker_ports
            docker_ports=$(grep ":${port}" /opt/vless/docker-compose.yml 2>/dev/null)
            if [ -n "$docker_ports" ]; then
                port_check_failed=true
                port_check_details+=("   - Docker Compose: порт уже проброшен")
            fi
        fi

        # Check if port is actually listening (netstat/ss)
        if command -v ss >/dev/null 2>&1; then
            local listening_port
            listening_port=$(ss -tuln | grep ":${port} " 2>/dev/null)
            if [ -n "$listening_port" ]; then
                port_check_failed=true
                port_check_details+=("   - Система: порт уже прослушивается")
            fi
        fi
    fi

    if [ "$port_check_failed" = true ]; then
        limitation_messages+=("❌ КРИТИЧНО: Порт $port недоступен")
        for detail in "${port_check_details[@]}"; do
            limitation_messages+=("$detail")
        done
        limitation_messages+=("   Используйте другой порт из диапазона 9443-9452")
        limitation_messages+=("   Свободные порты можно посмотреть: sudo vless-proxy list")
        has_limitations=true
    else
        print_success "Порт $port доступен"
    fi

    # Check 4: Domain already exists
    print_step "Проверка существования домена в БД..."

    if proxy_exists "$domain" 2>/dev/null; then
        limitation_messages+=("❌ КРИТИЧНО: Домен $domain уже существует в БД")
        limitation_messages+=("   Удалите существующий прокси: sudo vless-proxy remove $domain")
        has_limitations=true
    else
        print_success "Домен $domain доступен"
    fi

    # Check 5: Cloudflare Bot Management detection
    print_step "Проверка Cloudflare защиты на $target..."

    local has_cloudflare=false
    local cloudflare_details=""
    local cf_detection_methods=()

    # Method 1: Check HTTP headers
    local cf_headers
    cf_headers=$(timeout 10 curl -sI --max-time 10 "https://$target" 2>/dev/null | grep -iE "cf-|cloudflare|server: cloudflare")

    if [ -n "$cf_headers" ]; then
        has_cloudflare=true
        cf_detection_methods+=("HTTP headers")
    fi

    # Method 2: Check for Cloudflare challenge page
    local cf_challenge
    cf_challenge=$(timeout 10 curl -sL --max-time 10 "https://$target" 2>/dev/null | grep -i "checking your browser\|cloudflare" | head -1)

    if [ -n "$cf_challenge" ]; then
        has_cloudflare=true
        cf_detection_methods+=("Challenge page detected")
    fi

    # Method 3: DNS resolution check (Cloudflare IP ranges)
    if command -v dig >/dev/null 2>&1; then
        local target_ip
        target_ip=$(dig +short "$target" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1)

        if [ -n "$target_ip" ]; then
            # Check if IP is in Cloudflare ranges (simplified check for common ranges)
            if echo "$target_ip" | grep -qE '^(104\.1[6-9]\.|104\.2[0-9]\.|104\.3[0-1]\.|172\.6[4-7]\.|173\.245\.|188\.114\.|190\.93\.|197\.234\.|198\.41\.|162\.158\.|104\.244\.)'; then
                has_cloudflare=true
                cf_detection_methods+=("IP in Cloudflare range: $target_ip")
            fi
        fi
    fi

    # Method 4: Try simple request with curl (403 Forbidden check)
    local http_code
    http_code=$(timeout 10 curl -s -o /dev/null -w "%{http_code}" --max-time 10 "https://$target" 2>/dev/null)

    if [ "$http_code" = "403" ]; then
        has_cloudflare=true
        cf_detection_methods+=("403 Forbidden response")
    fi

    if [ "$has_cloudflare" = true ]; then
        cloudflare_details="Методы обнаружения: ${cf_detection_methods[*]}"

        warnings+=("")
        warnings+=("═══════════════════════════════════════════════════════════════")
        warnings+=("⚠️  ${BOLD}ОБНАРУЖЕНА CLOUDFLARE ЗАЩИТА${NC}")
        warnings+=("═══════════════════════════════════════════════════════════════")
        warnings+=("")
        warnings+=("   Целевой сайт: ${BOLD}$target${NC}")
        warnings+=("   $cloudflare_details")
        warnings+=("")
        warnings+=("   ${RED}${BOLD}ВАЖНО:${NC} Reverse proxy ${RED}НЕ БУДЕТ РАБОТАТЬ${NC} для этого сайта!")
        warnings+=("   Cloudflare Bot Management блокирует подозрительные запросы.")
        warnings+=("")
        warnings+=("   ${YELLOW}Примеры сайтов с Cloudflare защитой:${NC}")
        warnings+=("   - claude.ai")
        warnings+=("   - chatgpt.com")
        warnings+=("   - notion.so")
        warnings+=("   - discord.com")
        warnings+=("")
        warnings+=("   ${GREEN}${BOLD}РЕКОМЕНДАЦИЯ: Используйте VLESS SOCKS5/HTTP прокси${NC}")
        warnings+=("   SOCKS5/HTTP прокси работают на уровне соединения и НЕ блокируются Cloudflare")
        warnings+=("")
        warnings+=("   ${CYAN}${BOLD}1. Получите credentials:${NC}")
        warnings+=("      $ sudo vless-status")
        warnings+=("")
        warnings+=("   ${CYAN}${BOLD}2. Настройте прокси в браузере:${NC}")
        warnings+=("")
        warnings+=("      ${BOLD}Chrome/Chromium/Brave:${NC}")
        warnings+=("      - Settings → System → Open proxy settings")
        warnings+=("      - Manual proxy: SOCKS5, localhost:1080")
        warnings+=("      - Расширения: SwitchyOmega, FoxyProxy")
        warnings+=("")
        warnings+=("      ${BOLD}Firefox:${NC}")
        warnings+=("      - Settings → Network Settings → Manual proxy")
        warnings+=("      - SOCKS Host: localhost, Port: 1080, SOCKS v5")
        warnings+=("      - ✓ Proxy DNS when using SOCKS v5")
        warnings+=("")
        warnings+=("      ${BOLD}Safari (macOS):${NC}")
        warnings+=("      - System Preferences → Network → Advanced → Proxies")
        warnings+=("      - SOCKS Proxy: localhost:1080")
        warnings+=("")
        warnings+=("      ${BOLD}Edge:${NC}")
        warnings+=("      - Settings → System → Open proxy settings")
        warnings+=("      - Manual proxy: SOCKS5, localhost:1080")
        warnings+=("")
        warnings+=("═══════════════════════════════════════════════════════════════")
        warnings+=("")
    else
        print_success "Cloudflare защита не обнаружена"
    fi

    # Check 6: Target site reachability
    print_step "Проверка доступности $target..."

    local target_reachable=false
    local target_http_code
    target_http_code=$(timeout 10 curl -s -o /dev/null -w "%{http_code}" --max-time 10 "https://$target" 2>/dev/null)

    if [ -n "$target_http_code" ] && [ "$target_http_code" != "000" ]; then
        if [ "$target_http_code" -ge 200 ] && [ "$target_http_code" -lt 400 ]; then
            target_reachable=true
            print_success "Целевой сайт доступен (HTTP $target_http_code)"
        elif [ "$target_http_code" -eq 403 ]; then
            warnings+=("⚠️  Сайт доступен, но возвращает 403 Forbidden")
            warnings+=("   Возможна защита от ботов или географические ограничения")
        else
            warnings+=("⚠️  Сайт вернул HTTP $target_http_code")
        fi
    else
        warnings+=("⚠️  Не удалось подключиться к $target")
        warnings+=("   Сайт может быть недоступен, заблокирован или требует VPN")
    fi

    # Check 7: DNS Pre-validation (v5.15 - Critical)
    print_step "Проверка DNS записей для $domain..."

    local dns_check_passed=false
    local a_record=""
    local aaaa_record=""

    # Method 1: dig command
    if command -v dig >/dev/null 2>&1; then
        a_record=$(dig +short A "$domain" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
        aaaa_record=$(dig +short AAAA "$domain" 2>/dev/null | grep -E '^[0-9a-f:]+$' | head -1)
    fi

    # Method 2: nslookup fallback (if dig not available)
    if [ -z "$a_record" ] && [ -z "$aaaa_record" ]; then
        if command -v nslookup >/dev/null 2>&1; then
            a_record=$(nslookup "$domain" 2>/dev/null | grep -A1 "Name:" | grep "Address:" | awk '{print $2}' | grep -v ':' | head -1)
        fi
    fi

    if [ -n "$a_record" ] || [ -n "$aaaa_record" ]; then
        # DNS records found
        dns_check_passed=true

        # Get current server IP
        local server_ip
        server_ip=$(timeout 5 curl -s ifconfig.me 2>/dev/null || timeout 5 curl -s icanhazip.com 2>/dev/null || echo "unknown")

        if [ -n "$a_record" ]; then
            if [ "$a_record" = "$server_ip" ]; then
                print_success "DNS A-запись указывает на этот сервер ($a_record)"
            else
                warnings+=("⚠️  DNS A-запись указывает на другой IP")
                warnings+=("   DNS запись: $a_record")
                warnings+=("   Этот сервер: $server_ip")
                warnings+=("")
                warnings+=("   ${YELLOW}Let's Encrypt будет проверять $a_record!${NC}")
                warnings+=("   Если это не этот сервер, сертификат НЕ БУДЕТ получен.")
            fi
        fi

        if [ -n "$aaaa_record" ]; then
            print_success "DNS AAAA-запись найдена ($aaaa_record)"
        fi
    else
        # No DNS records found - CRITICAL ERROR
        limitation_messages+=("❌ КРИТИЧНО: DNS записи не найдены для $domain")
        limitation_messages+=("")
        limitation_messages+=("   ${BOLD}Требуемые действия:${NC}")
        limitation_messages+=("   1. Добавьте A-запись в DNS провайдере:")
        limitation_messages+=("      Type: A")
        limitation_messages+=("      Name: $domain")
        limitation_messages+=("      Value: \$(curl -s ifconfig.me)  # IP этого сервера")
        limitation_messages+=("      TTL: 300 (или авто)")
        limitation_messages+=("")
        limitation_messages+=("   2. Дождитесь распространения DNS (5-60 минут):")
        limitation_messages+=("      $ dig +short $domain")
        limitation_messages+=("      # Должен вернуть IP этого сервера")
        limitation_messages+=("")
        limitation_messages+=("   3. Запустите wizard снова после настройки DNS")
        has_limitations=true
    fi

    # Check 8: fail2ban Status (v5.15 - Warning)
    print_step "Проверка fail2ban защиты..."

    local fail2ban_ok=false

    if systemctl is-active --quiet fail2ban 2>/dev/null; then
        # fail2ban is running
        if sudo fail2ban-client status vless-reverseproxy >/dev/null 2>&1; then
            # Jail is configured
            local jail_info
            jail_info=$(sudo fail2ban-client status vless-reverseproxy 2>/dev/null)
            local banned_count
            banned_count=$(echo "$jail_info" | grep "Currently banned:" | awk '{print $NF}')

            print_success "fail2ban активен (защита от brute-force)"
            print_info "  Jail: vless-reverseproxy | Забанено IP: ${banned_count:-0}"
            fail2ban_ok=true
        else
            warnings+=("⚠️  fail2ban запущен, но jail vless-reverseproxy не настроен")
            warnings+=("   Reverse proxy будет работать БЕЗ защиты от brute-force атак")
        fi
    else
        warnings+=("⚠️  ВНИМАНИЕ: fail2ban не запущен")
        warnings+=("")
        warnings+=("   Reverse proxy будет работать, но БЕЗ защиты от brute-force!")
        warnings+=("")
        warnings+=("   ${CYAN}Рекомендуемые действия:${NC}")
        warnings+=("   1. Запустить fail2ban:")
        warnings+=("      $ sudo systemctl start fail2ban")
        warnings+=("      $ sudo systemctl enable fail2ban")
        warnings+=("")
        warnings+=("   2. Проверить статус:")
        warnings+=("      $ sudo fail2ban-client status vless-reverseproxy")
    fi

    # Check 9: Rate Limit Zone (v5.15 - Critical with auto-fix)
    print_step "Проверка rate limit zone конфигурации..."

    local zone_name="reverseproxy_${domain//[.-]/_}"
    local http_context="/opt/vless/config/reverse-proxy/http_context.conf"

    if [ -f "$http_context" ]; then
        if grep -q "limit_req_zone.*zone=${zone_name}" "$http_context" 2>/dev/null; then
            print_success "Rate limit zone уже существует"
        else
            print_warning "Rate limit zone отсутствует, выполняем auto-fix..."

            # Auto-fix: Add rate limit zone
            sudo bash -c "cat >> $http_context << EOF

# Rate limit zone for: ${domain} (v5.15 auto-added)
limit_req_zone \\\$binary_remote_addr zone=${zone_name}:10m rate=100r/s;
EOF"

            if grep -q "limit_req_zone.*zone=${zone_name}" "$http_context" 2>/dev/null; then
                print_success "Rate limit zone добавлена автоматически"
            else
                limitation_messages+=("❌ КРИТИЧНО: Не удалось добавить rate limit zone")
                limitation_messages+=("   Nginx может не запуститься из-за отсутствующей зоны")
                limitation_messages+=("   Требуется ручная настройка: $http_context")
                has_limitations=true
            fi
        fi
    else
        warnings+=("⚠️  Файл http_context.conf не найден")
        warnings+=("   Создастся автоматически при генерации конфигурации")
    fi

    # Check 10: HAProxy Config Syntax (v5.15 - Critical)
    print_step "Проверка синтаксиса HAProxy конфигурации..."

    local haproxy_config="/opt/vless/config/haproxy.cfg"

    if [ -f "$haproxy_config" ]; then
        # Validate syntax using running HAProxy container (has access to certificates)
        # v5.16: Changed from 'docker run' to 'docker exec' to access mounted certificates
        local validation_output
        validation_output=$(docker exec vless_haproxy haproxy -c -f /usr/local/etc/haproxy/haproxy.cfg 2>&1)
        local validation_exit=$?

        if [ $validation_exit -eq 0 ]; then
            print_success "HAProxy конфигурация валидна"

            # Check if certificate exists
            if [ -f "/opt/vless/certs/combined.pem" ]; then
                print_success "HAProxy сертификат найден"
            else
                warnings+=("⚠️  HAProxy сертификат отсутствует")
                warnings+=("   Будет создан автоматически при получении Let's Encrypt сертификата")
            fi
        else
            limitation_messages+=("❌ КРИТИЧНО: HAProxy конфигурация содержит ошибки")
            limitation_messages+=("")
            limitation_messages+=("   ${BOLD}Вывод проверки:${NC}")
            echo "$validation_output" | head -10 | while read line; do
                limitation_messages+=("   $line")
            done
            limitation_messages+=("")
            limitation_messages+=("   ${BOLD}Требуемые действия:${NC}")
            limitation_messages+=("   1. Проверьте синтаксис вручную:")
            limitation_messages+=("      $ docker exec vless_haproxy haproxy -c -f /usr/local/etc/haproxy/haproxy.cfg")
            limitation_messages+=("")
            limitation_messages+=("   2. Восстановите из бэкапа (если доступен):")
            limitation_messages+=("      $ sudo cp /opt/vless/config/haproxy.cfg.bak /opt/vless/config/haproxy.cfg")
            limitation_messages+=("")
            limitation_messages+=("   3. НЕ продолжайте установку до исправления!")
            has_limitations=true
        fi
    else
        limitation_messages+=("❌ КРИТИЧНО: HAProxy конфигурация не найдена")
        limitation_messages+=("   Файл отсутствует: $haproxy_config")
        limitation_messages+=("   Требуется переустановка VLESS VPN сервера")
        has_limitations=true
    fi

    # Display results
    echo "" >&2
    echo "═══════════════════════════════════════════════════════════════" >&2

    # Show critical limitations
    if [ "$has_limitations" = true ]; then
        echo -e "${RED}${BOLD}ОБНАРУЖЕНЫ КРИТИЧЕСКИЕ ОГРАНИЧЕНИЯ:${NC}" >&2
        echo "" >&2
        for msg in "${limitation_messages[@]}"; do
            echo -e "${RED}$msg${NC}" >&2
        done
        echo "" >&2
        echo "═══════════════════════════════════════════════════════════════" >&2
        echo "" >&2

        print_error "Невозможно продолжить установку из-за критических ограничений"
        print_info "Исправьте проблемы и запустите wizard снова"

        return 1  # Block installation
    fi

    # Show warnings (non-blocking)
    if [ ${#warnings[@]} -gt 0 ]; then
        echo -e "${YELLOW}${BOLD}ПРЕДУПРЕЖДЕНИЯ:${NC}" >&2
        echo "" >&2
        for msg in "${warnings[@]}"; do
            echo -e "${YELLOW}$msg${NC}" >&2
        done
        echo "" >&2
        echo "═══════════════════════════════════════════════════════════════" >&2
        echo "" >&2

        # Ask for confirmation
        echo -e "${YELLOW}${BOLD}Обнаружены потенциальные проблемы.${NC}" >&2
        echo "" >&2
        read -p "Вы уверены что хотите продолжить? [y/N]: " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_warning "Установка отменена пользователем"
            return 1
        fi

        echo "" >&2
    else
        echo -e "${GREEN}${BOLD}✅ ВСЕ ПРОВЕРКИ ПРОЙДЕНЫ${NC}" >&2
        echo "" >&2
        echo "═══════════════════════════════════════════════════════════════" >&2
        echo "" >&2
    fi

    return 0
}

prompt_confirmation() {
    local domain="$1"
    local target="$2"
    local port="$3"
    local email="$4"

    print_header "Подтверждение Конфигурации"

    echo -e "${CYAN}${BOLD}Проверьте параметры:${NC}" >&2
    echo "" >&2
    echo -e "  ${BOLD}Домен:${NC}           $domain" >&2
    echo -e "  ${BOLD}Целевой сайт:${NC}    $target" >&2
    echo -e "  ${BOLD}Backend порт:${NC}    $port (localhost-only)" >&2
    echo -e "  ${BOLD}Email:${NC}           $email" >&2
    echo "" >&2
    echo -e "  ${BOLD}Публичный URL:${NC}   ${GREEN}https://${domain}${NC}  ${YELLOW}(БЕЗ номера порта!)${NC}" >&2
    echo "" >&2
    echo -e "${CYAN}${BOLD}Дополнительные опции (v5.13):${NC}" >&2
    echo -e "  ${BOLD}OAuth2 Support:${NC}          ${OAUTH2_SUPPORT:-true}" >&2
    echo -e "  ${BOLD}WebSocket Support:${NC}       ${ENABLE_WEBSOCKET:-true}" >&2
    echo -e "  ${BOLD}Strip CSP Headers:${NC}       ${STRIP_CSP:-true}" >&2
    echo -e "  ${BOLD}Enhanced Security:${NC}       ${ENHANCED_SECURITY_HEADERS:-false}" >&2
    echo -e "  ${BOLD}Custom User-Agent:${NC}       ${CUSTOM_USER_AGENT:0:60}..." >&2
    echo "" >&2
    echo -e "${YELLOW}${BOLD}Что будет выполнено (v4.3):${NC}" >&2
    echo "  1. DNS validation (обязательно!)" >&2
    echo "  2. Получение Let's Encrypt сертификата для $domain" >&2
    echo "  3. Создание HAProxy combined.pem (fullchain + privkey)" >&2
    echo "  4. Создание Nginx reverse proxy конфигурации (localhost:$port)" >&2
    echo "  5. Создание Xray HTTP inbound (localhost:10080+)" >&2
    echo "  6. Добавление HAProxy SNI route: $domain → nginx:$port" >&2
    echo "  7. Настройка fail2ban защиты" >&2
    echo "  8. Генерация HTTP Basic Auth креденшелов" >&2
    echo "" >&2
    echo -e "${CYAN}${ICON_INFO} v4.3 Architecture:${NC}" >&2
    echo "  - HAProxy (port 443) принимает все HTTPS трафик" >&2
    echo "  - SNI routing по имени домена (TLS passthrough НЕ используется)" >&2
    echo "  - Nginx backend слушает ТОЛЬКО на 127.0.0.1:$port" >&2
    echo "  - UFW порт НЕ открывается (не нужен, HAProxy уже на 443)" >&2
    echo "" >&2

    read -p "Продолжить установку? [y/N]: " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_warning "Установка отменена пользователем"
        exit 0
    fi
}

# =============================================================================
# Installation Functions
# =============================================================================

setup_reverse_proxy() {
    local domain="$1"
    local target="$2"
    local port="$3"
    local email="$4"

    print_header "Установка Reverse Proxy"

    # Step 1: Unified Certificate Acquisition (v4.3)
    # Includes: DNS validation + certbot + HAProxy combined.pem + reload
    print_step "Получение Let's Encrypt сертификата (v4.3 unified workflow)..."
    if ! acquire_certificate_for_domain "$domain" "$email"; then
        print_error "Не удалось получить сертификат"
        print_error "Проверьте DNS: dig +short $domain"
        return 1
    fi

    # Step 2: Xray HTTP inbound (DEPRECATED in v5.3)
    # v5.3: Nginx proxies directly to target site via HTTPS (IPv4-only)
    # Xray inbound no longer needed for reverse proxy
    local xray_tag="N/A"
    local xray_port="N/A"

    # Step 3: Generate HTTP Basic Auth credentials
    print_step "Генерация креденшелов..."
    local username="user_$(openssl rand -hex 4)"
    local password=$(openssl rand -hex 16)
    local password_hash
    password_hash=$(htpasswd -nbB "$username" "$password" | cut -d: -f2)

    print_success "Username: $username"
    print_success "Password: $password"

    # Step 4: Generate Nginx configuration
    print_step "Создание Nginx конфигурации..."
    if ! generate_reverseproxy_nginx_config "$domain" "$target" "$port" "$username" "$password_hash"; then
        print_error "Не удалось создать Nginx конфигурацию"
        return 1
    fi

    # Step 4.5: Add rate limit zone (CRITICAL FIX v5.13)
    # This MUST be called after generate_reverseproxy_nginx_config
    # to add limit_req_zone directive to http_context.conf
    print_step "Добавление rate limit zone..."
    if ! add_rate_limit_zone "$domain"; then
        print_error "Не удалось добавить rate limit zone"
        return 1
    fi

    # Step 5: Add entry to database
    print_step "Сохранение конфигурации в БД..."
    local cert_expires
    cert_expires="$(date -u -d '+90 days' +"%Y-%m-%dT%H:%M:%SZ")"
    local notes="Created via vless-setup-proxy wizard"

    # add_proxy: domain, target_site, port, username, password, xray_port, xray_tag, cert_expires, target_ipv4, notes
    # target_ipv4 is resolved automatically inside add_proxy() if empty
    if ! add_proxy "$domain" "$target" "$port" "$username" "$password" "$xray_port" "$xray_tag" "$cert_expires" "" "$notes"; then
        print_error "Не удалось сохранить конфигурацию в БД"
        return 1
    fi

    # Step 6: Add port to fail2ban
    print_step "Настройка fail2ban защиты..."
    if ! add_port_to_jail "$port"; then
        print_warning "Не удалось добавить порт в fail2ban (не критично)"
    else
        reload_fail2ban
    fi

    # Step 7: Add port to docker-compose.yml (nginx localhost binding)
    print_step "Добавление порта в docker-compose.yml..."
    if ! add_nginx_port "$port"; then
        print_error "Не удалось добавить порт в docker-compose.yml"
        print_warning "Порт придётся добавить вручную"
    else
        print_success "Порт $port добавлен в docker-compose.yml"
    fi

    # Step 8: Add HAProxy SNI route (v4.3)
    print_step "Добавление HAProxy SNI route..."
    if ! add_reverse_proxy_route "$domain" "$port"; then
        print_error "Не удалось добавить HAProxy route"
        print_warning "Маршрут придётся добавить вручную"
    else
        print_success "HAProxy route добавлен: $domain → nginx:$port"
    fi

    # Step 9: Reload services
    print_step "Перезагрузка сервисов..."
    reload_nginx_container  # Docker compose restart with new port
    # Note: reload_xray() not needed (v5.3+: nginx proxies directly to target, no Xray HTTP inbound)

    # Step 10: Display success message
    print_header "${ICON_SUCCESS} Reverse Proxy Успешно Настроен!"

    echo "" >&2
    echo -e "${GREEN}${BOLD}Reverse Proxy готов к использованию!${NC}" >&2
    echo "" >&2
    echo -e "${CYAN}${BOLD}Детали конфигурации (v4.3):${NC}" >&2
    echo -e "  ${BOLD}URL:${NC}      ${GREEN}https://${domain}${NC}  ${YELLOW}(БЕЗ номера порта!)${NC}" >&2
    echo -e "  ${BOLD}Backend:${NC}  127.0.0.1:${port} (localhost-only)" >&2
    echo -e "  ${BOLD}Username:${NC} $username" >&2
    echo -e "  ${BOLD}Password:${NC} $password" >&2
    echo "" >&2
    echo -e "${YELLOW}${BOLD}Как использовать:${NC}" >&2
    echo "  1. Откройте браузер" >&2
    echo "  2. Перейдите по адресу: ${GREEN}${BOLD}https://${domain}${NC}" >&2
    echo "  3. Введите username/password при запросе" >&2
    echo "  4. Вы будете перенаправлены на ${target}" >&2
    echo "" >&2
    echo -e "${CYAN}${ICON_INFO} v4.3 HAProxy Routing:${NC}" >&2
    echo "  - HAProxy принимает HTTPS запросы на порту 443" >&2
    echo "  - SNI-based routing: по имени домена ($domain)" >&2
    echo "  - Nginx backend слушает только localhost (недоступен извне)" >&2
    echo "" >&2
    echo -e "${CYAN}Управление:${NC}" >&2
    echo "  sudo vless-proxy show ${domain}        # Показать детали" >&2
    echo "  sudo vless-proxy remove ${domain}      # Удалить" >&2
    echo "  sudo vless-proxy renew-cert ${domain}  # Обновить сертификат" >&2
    echo "" >&2

    return 0
}

# =============================================================================
# Main Execution
# =============================================================================

main() {
    # Check if running as root
    if [ "$EUID" -ne 0 ]; then
        print_error "Этот скрипт должен быть запущен с sudo"
        exit 1
    fi

    # Check if VLESS is installed
    if [ ! -d "$INSTALL_PATH" ]; then
        print_error "VLESS не установлен. Сначала запустите установку."
        exit 1
    fi

    # Initialize database if not exists
    init_database

    # Print welcome banner
    clear
    print_header "${ICON_ROCKET} VLESS v4.3 - Reverse Proxy Setup Wizard (HAProxy Unified)"

    echo -e "${CYAN}Этот wizard поможет настроить reverse proxy для доступа к заблокированным сайтам.${NC}" >&2
    echo -e "${YELLOW}v4.3: Unified HAProxy architecture - subdomain access без номера порта!${NC}" >&2
    echo "" >&2

    # Collect parameters
    domain=$(prompt_domain)
    target=$(prompt_target_site)
    port=$(prompt_port)
    email=$(prompt_letsencrypt_email)

    # v5.10: Advanced options (OAuth2, WebSocket, CSP)
    prompt_advanced_options

    # v5.14: Pre-flight checks (blocking if critical issues found)
    if ! check_proxy_limitations "$domain" "$target" "$port"; then
        print_error "Установка прервана из-за ограничений"
        exit 1
    fi

    # Confirmation
    prompt_confirmation "$domain" "$target" "$port" "$email"

    # Execute setup (success message printed inside function)
    if ! setup_reverse_proxy "$domain" "$target" "$port" "$email"; then
        print_error "Установка завершилась с ошибками"
        exit 1
    fi
}

# Run main function
main "$@"
