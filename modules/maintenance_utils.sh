#!/bin/bash

# VLESS+Reality VPN Management System - Maintenance Utilities
# Version: 1.0.0
# Description: Automated maintenance and optimization utilities
#
# Features:
# - Automatic system updates
# - Log file cleanup and rotation
# - Docker image updates
# - Database optimization
# - Disk space management
# - Performance tuning
# - Process isolation for EPERM prevention

set -euo pipefail

# Import common utilities
SOURCE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SOURCE_DIR}/common_utils.sh"

# Setup signal handlers
setup_signal_handlers

# Configuration
readonly MAINTENANCE_CONFIG_DIR="/opt/vless/config/maintenance"
readonly MAINTENANCE_LOG_DIR="/opt/vless/logs/maintenance"
readonly MAINTENANCE_DATA_DIR="/opt/vless/data/maintenance"
readonly MAINTENANCE_TEMP_DIR="/tmp/vless_maintenance"

# Maintenance settings
readonly DISK_CLEANUP_THRESHOLD=80
readonly LOG_CLEANUP_DAYS=30
readonly UPDATE_CHECK_INTERVAL=86400  # 24 hours
readonly MAINTENANCE_LOCK_FILE="/var/lock/vless_maintenance.lock"

# Initialize maintenance utilities
init_maintenance_utils() {
    log_info "Initializing maintenance utilities module"

    # Create maintenance directories
    create_directory "$MAINTENANCE_CONFIG_DIR" "750" "vless:vless"
    create_directory "$MAINTENANCE_LOG_DIR" "750" "vless:vless"
    create_directory "$MAINTENANCE_DATA_DIR" "750" "vless:vless"
    create_directory "$MAINTENANCE_TEMP_DIR" "700" "root:root"

    # Install required packages
    install_package_if_missing "apt-utils"
    install_package_if_missing "unattended-upgrades"
    install_package_if_missing "apt-listchanges"

    # Create maintenance configuration
    create_maintenance_config

    log_success "Maintenance utilities module initialized"
}

# Create maintenance configuration
create_maintenance_config() {
    log_info "Creating maintenance configuration"

    local maintenance_config="${MAINTENANCE_CONFIG_DIR}/maintenance.conf"

    cat > "$maintenance_config" << 'EOF'
# VLESS Maintenance Configuration
# Generated by maintenance utilities module

# System update settings
ENABLE_AUTO_UPDATES=true
SECURITY_UPDATES_ONLY=true
UPDATE_CHECK_INTERVAL=86400
REBOOT_IF_REQUIRED=false
REBOOT_TIME="03:00"

# Cleanup settings
ENABLE_LOG_CLEANUP=true
LOG_RETENTION_DAYS=30
ENABLE_DISK_CLEANUP=true
DISK_CLEANUP_THRESHOLD=80
ENABLE_DOCKER_CLEANUP=true
DOCKER_CLEANUP_INTERVAL=604800  # 7 days

# Database optimization
ENABLE_DB_OPTIMIZATION=true
DB_OPTIMIZATION_INTERVAL=2592000  # 30 days

# Performance tuning
ENABLE_PERFORMANCE_TUNING=true
OPTIMIZE_NETWORK_STACK=true
OPTIMIZE_KERNEL_PARAMS=true

# Monitoring settings
ENABLE_HEALTH_MONITORING=true
HEALTH_CHECK_INTERVAL=300
ENABLE_ALERTS=true
ALERT_EMAIL=""
ALERT_WEBHOOK=""

# Backup settings
ENABLE_MAINTENANCE_BACKUP=true
BACKUP_BEFORE_UPDATES=true
BACKUP_RETENTION_DAYS=7

EOF

    chmod 644 "$maintenance_config"
    chown vless:vless "$maintenance_config"

    log_success "Maintenance configuration created: $maintenance_config"
}

# Acquire maintenance lock
acquire_maintenance_lock() {
    local operation="$1"
    local timeout="${2:-300}"

    log_debug "Acquiring maintenance lock for operation: $operation"

    local lock_acquired=false
    local elapsed=0

    while [[ $elapsed -lt $timeout ]]; do
        if (set -C; echo "$$:$operation:$(date)" > "$MAINTENANCE_LOCK_FILE") 2>/dev/null; then
            lock_acquired=true
            break
        fi

        # Check if existing lock is stale
        if [[ -f "$MAINTENANCE_LOCK_FILE" ]]; then
            local lock_pid
            lock_pid=$(cut -d':' -f1 "$MAINTENANCE_LOCK_FILE" 2>/dev/null || echo "")
            if [[ -n "$lock_pid" ]] && ! kill -0 "$lock_pid" 2>/dev/null; then
                log_warn "Removing stale maintenance lock (PID: $lock_pid)"
                rm -f "$MAINTENANCE_LOCK_FILE"
                continue
            fi
        fi

        sleep 5
        elapsed=$((elapsed + 5))
    done

    if [[ "$lock_acquired" == "true" ]]; then
        log_debug "Maintenance lock acquired"
        return 0
    else
        log_error "Failed to acquire maintenance lock within ${timeout}s"
        return 1
    fi
}

# Release maintenance lock
release_maintenance_lock() {
    if [[ -f "$MAINTENANCE_LOCK_FILE" ]]; then
        rm -f "$MAINTENANCE_LOCK_FILE"
        log_debug "Maintenance lock released"
    fi
}

# System updates
perform_system_updates() {
    local update_type="${1:-security}"
    local auto_reboot="${2:-false}"

    log_info "Performing system updates (type: $update_type)"

    if ! acquire_maintenance_lock "system_updates" 600; then
        return 1
    fi

    # Ensure proper cleanup
    trap 'release_maintenance_lock' EXIT

    # Update package lists with time sync support
    log_info "Updating package lists"
    safe_apt_update

    # Check for available updates
    local updates_available
    updates_available=$(apt list --upgradable 2>/dev/null | grep -c upgradable || echo "0")

    if [[ $updates_available -eq 0 ]]; then
        log_info "No updates available"
        return 0
    fi

    log_info "Found $updates_available available updates"

    # Create pre-update backup if enabled
    local maintenance_config="${MAINTENANCE_CONFIG_DIR}/maintenance.conf"
    if [[ -f "$maintenance_config" ]]; then
        source "$maintenance_config"
        if [[ "${BACKUP_BEFORE_UPDATES:-false}" == "true" ]]; then
            log_info "Creating pre-update backup"
            if command -v create_full_backup >/dev/null 2>&1; then
                create_full_backup "pre_update_$(date +%Y%m%d_%H%M%S)" "Pre-update backup"
            fi
        fi
    fi

    # Perform updates based on type
    case "$update_type" in
        "security")
            log_info "Installing security updates only"
            unattended-upgrade -v
            ;;
        "all")
            log_info "Installing all available updates"
            DEBIAN_FRONTEND=noninteractive apt-get -y upgrade
            ;;
        "dist-upgrade")
            log_info "Performing distribution upgrade"
            DEBIAN_FRONTEND=noninteractive apt-get -y dist-upgrade
            ;;
        *)
            log_error "Invalid update type: $update_type"
            return 1
            ;;
    esac

    # Clean up package cache
    apt-get autoremove -y
    apt-get autoclean

    # Check if reboot is required
    if [[ -f /var/run/reboot-required ]]; then
        log_warn "System reboot required after updates"

        if [[ "$auto_reboot" == "true" ]]; then
            log_info "Scheduling system reboot"
            shutdown -r +5 "System reboot required after VLESS maintenance updates"
        else
            echo "REBOOT_REQUIRED" > "${MAINTENANCE_DATA_DIR}/reboot_required"
        fi
    fi

    log_success "System updates completed successfully"
}

# Log cleanup
perform_log_cleanup() {
    local retention_days="${1:-$LOG_CLEANUP_DAYS}"

    log_info "Performing log cleanup (retention: $retention_days days)"

    if ! acquire_maintenance_lock "log_cleanup" 300; then
        return 1
    fi

    trap 'release_maintenance_lock' EXIT

    local cleaned_files=0
    local freed_space=0

    # VLESS logs cleanup
    if [[ -d "/opt/vless/logs" ]]; then
        log_debug "Cleaning VLESS logs older than $retention_days days"

        while IFS= read -r -d '' log_file; do
            local file_size
            file_size=$(stat -c%s "$log_file" 2>/dev/null || echo "0")
            rm -f "$log_file"
            ((cleaned_files++))
            freed_space=$((freed_space + file_size))
        done < <(find "/opt/vless/logs" -name "*.log" -type f -mtime +$retention_days -print0 2>/dev/null)
    fi

    # System logs cleanup
    log_debug "Cleaning system logs"

    # Clean journal logs older than retention period
    journalctl --vacuum-time="${retention_days}d" >/dev/null 2>&1 || true

    # Clean rotated logs
    find /var/log -name "*.gz" -mtime +$retention_days -delete 2>/dev/null || true
    find /var/log -name "*.1" -mtime +$retention_days -delete 2>/dev/null || true

    # Clean temporary files
    find /tmp -name "*vless*" -mtime +1 -delete 2>/dev/null || true
    find /var/tmp -name "*vless*" -mtime +1 -delete 2>/dev/null || true

    # Convert freed space to human readable
    local freed_space_hr
    freed_space_hr=$(human_readable_size $freed_space)

    log_success "Log cleanup completed. Cleaned $cleaned_files files, freed $freed_space_hr"
}

# Docker cleanup
perform_docker_cleanup() {
    log_info "Performing Docker cleanup"

    if ! acquire_maintenance_lock "docker_cleanup" 300; then
        return 1
    fi

    trap 'release_maintenance_lock' EXIT

    if ! command_exists docker; then
        log_warn "Docker not installed, skipping Docker cleanup"
        return 0
    fi

    # Stop VLESS containers temporarily
    local vless_containers
    vless_containers=$(docker ps --filter "name=vless" --format "{{.Names}}" 2>/dev/null || echo "")

    # Clean up unused Docker resources
    log_debug "Cleaning unused Docker images"
    docker image prune -f >/dev/null 2>&1 || true

    log_debug "Cleaning unused Docker containers"
    docker container prune -f >/dev/null 2>&1 || true

    log_debug "Cleaning unused Docker volumes"
    docker volume prune -f >/dev/null 2>&1 || true

    log_debug "Cleaning unused Docker networks"
    docker network prune -f >/dev/null 2>&1 || true

    # Clean Docker build cache
    log_debug "Cleaning Docker build cache"
    docker builder prune -f >/dev/null 2>&1 || true

    # Get space freed
    local docker_info
    docker_info=$(docker system df --format "table {{.Type}}\t{{.TotalCount}}\t{{.Size}}\t{{.Reclaimable}}" 2>/dev/null || echo "")

    log_success "Docker cleanup completed"
    if [[ -n "$docker_info" ]]; then
        echo "Docker storage usage:"
        echo "$docker_info"
    fi
}

# Database optimization
perform_database_optimization() {
    log_info "Performing database optimization"

    if ! acquire_maintenance_lock "database_optimization" 300; then
        return 1
    fi

    trap 'release_maintenance_lock' EXIT

    # VLESS user database optimization
    local user_db_file="/opt/vless/users/users.json"

    if [[ -f "$user_db_file" ]]; then
        log_debug "Optimizing VLESS user database"

        # Create backup
        local backup_file="${user_db_file}.backup.$(date +%Y%m%d_%H%M%S)"
        cp "$user_db_file" "$backup_file"

        # Validate and reformat JSON
        if jq . "$user_db_file" > "${user_db_file}.tmp" 2>/dev/null; then
            mv "${user_db_file}.tmp" "$user_db_file"
            chmod 640 "$user_db_file"
            chown vless:vless "$user_db_file"
            log_debug "User database optimized and reformatted"
        else
            log_warn "User database JSON validation failed, skipping optimization"
            rm -f "${user_db_file}.tmp"
        fi

        # Clean old backups
        find "$(dirname "$user_db_file")" -name "*.backup.*" -mtime +7 -delete 2>/dev/null || true
    fi

    # Optimize configuration files
    log_debug "Optimizing configuration files"

    local config_files=(
        "/opt/vless/config/xray_config.json"
        "/opt/vless/config/docker-compose.yml"
    )

    local file
    for file in "${config_files[@]}"; do
        if [[ -f "$file" ]]; then
            # Validate and optimize JSON files
            if [[ "$file" == *.json ]]; then
                if jq . "$file" > "${file}.tmp" 2>/dev/null; then
                    mv "${file}.tmp" "$file"
                    log_debug "Optimized: $file"
                else
                    rm -f "${file}.tmp"
                    log_warn "Failed to optimize: $file"
                fi
            fi
        fi
    done

    log_success "Database optimization completed"
}

# Disk space management
perform_disk_cleanup() {
    local threshold="${1:-$DISK_CLEANUP_THRESHOLD}"

    log_info "Performing disk cleanup (threshold: $threshold%)"

    # Check current disk usage
    local disk_usage
    disk_usage=$(df /opt/vless | awk 'NR==2{print $5}' | sed 's/%//')

    if [[ $disk_usage -lt $threshold ]]; then
        log_info "Disk usage ($disk_usage%) below threshold ($threshold%), no cleanup needed"
        return 0
    fi

    log_warn "Disk usage ($disk_usage%) exceeds threshold ($threshold%), starting cleanup"

    if ! acquire_maintenance_lock "disk_cleanup" 600; then
        return 1
    fi

    trap 'release_maintenance_lock' EXIT

    local initial_usage=$disk_usage
    local cleaned_items=0

    # Clean temporary files
    log_debug "Cleaning temporary files"
    find /tmp -type f -atime +1 -delete 2>/dev/null || true
    find /var/tmp -type f -atime +1 -delete 2>/dev/null || true
    ((cleaned_items++))

    # Clean package cache
    log_debug "Cleaning package cache"
    apt-get clean >/dev/null 2>&1 || true
    ((cleaned_items++))

    # Clean old log files
    log_debug "Cleaning old log files"
    perform_log_cleanup 7
    ((cleaned_items++))

    # Clean old backups if disk usage is still high
    disk_usage=$(df /opt/vless | awk 'NR==2{print $5}' | sed 's/%//')
    if [[ $disk_usage -gt $threshold ]]; then
        log_debug "Cleaning old backups"
        if command -v cleanup_old_backups >/dev/null 2>&1; then
            cleanup_old_backups
            ((cleaned_items++))
        fi
    fi

    # Clean Docker resources if disk usage is still high
    disk_usage=$(df /opt/vless | awk 'NR==2{print $5}' | sed 's/%//')
    if [[ $disk_usage -gt $threshold ]]; then
        log_debug "Performing aggressive Docker cleanup"
        perform_docker_cleanup
        ((cleaned_items++))
    fi

    # Final disk usage check
    local final_usage
    final_usage=$(df /opt/vless | awk 'NR==2{print $5}' | sed 's/%//')
    local space_freed=$((initial_usage - final_usage))

    log_success "Disk cleanup completed. Usage: $initial_usage% -> $final_usage% (freed: $space_freed%)"
    log_info "Cleaned $cleaned_items categories of files"

    if [[ $final_usage -gt $threshold ]]; then
        log_warn "Disk usage still above threshold after cleanup"
        return 1
    fi

    return 0
}

# Performance tuning
perform_performance_tuning() {
    log_info "Performing performance tuning"

    if ! acquire_maintenance_lock "performance_tuning" 300; then
        return 1
    fi

    trap 'release_maintenance_lock' EXIT

    # Network stack optimization
    log_debug "Optimizing network stack"

    # TCP congestion control
    if ! sysctl net.ipv4.tcp_congestion_control | grep -q bbr; then
        sysctl -w net.ipv4.tcp_congestion_control=bbr >/dev/null 2>&1 || true
        sysctl -w net.core.default_qdisc=fq >/dev/null 2>&1 || true
    fi

    # TCP buffer sizes
    sysctl -w net.core.rmem_default=262144 >/dev/null 2>&1 || true
    sysctl -w net.core.rmem_max=16777216 >/dev/null 2>&1 || true
    sysctl -w net.core.wmem_default=262144 >/dev/null 2>&1 || true
    sysctl -w net.core.wmem_max=16777216 >/dev/null 2>&1 || true

    # File descriptor limits
    log_debug "Optimizing file descriptor limits"

    # Create limits configuration
    local limits_file="/etc/security/limits.d/vless.conf"
    if [[ ! -f "$limits_file" ]]; then
        cat > "$limits_file" << 'EOF'
# VLESS performance limits
vless soft nofile 65536
vless hard nofile 65536
* soft nofile 65536
* hard nofile 65536
EOF
        chmod 644 "$limits_file"
    fi

    # Optimize I/O scheduler
    log_debug "Optimizing I/O scheduler"
    local block_devices
    block_devices=$(lsblk -dnro NAME 2>/dev/null | grep -E '^[sv]d[a-z]$')

    while IFS= read -r device; do
        if [[ -n "$device" ]]; then
            echo "mq-deadline" > "/sys/block/$device/queue/scheduler" 2>/dev/null || true
        fi
    done <<< "$block_devices"

    # Memory optimization
    log_debug "Optimizing memory settings"
    sysctl -w vm.swappiness=10 >/dev/null 2>&1 || true
    sysctl -w vm.vfs_cache_pressure=50 >/dev/null 2>&1 || true

    log_success "Performance tuning completed"
}

# Docker image updates
update_docker_images() {
    log_info "Updating Docker images"

    if ! acquire_maintenance_lock "docker_updates" 600; then
        return 1
    fi

    trap 'release_maintenance_lock' EXIT

    if ! command_exists docker; then
        log_warn "Docker not installed, skipping image updates"
        return 0
    fi

    # Get current VLESS images
    local current_images
    current_images=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -E "(xray|v2ray)" || echo "")

    if [[ -z "$current_images" ]]; then
        log_warn "No VLESS-related images found"
        return 0
    fi

    # Pull latest images
    log_debug "Pulling latest Docker images"
    while IFS= read -r image; do
        if [[ -n "$image" ]]; then
            log_debug "Updating image: $image"
            docker pull "$image" >/dev/null 2>&1 || log_warn "Failed to update image: $image"
        fi
    done <<< "$current_images"

    # Restart services with updated images
    log_debug "Restarting VLESS services with updated images"

    local compose_file="/opt/vless/config/docker-compose.yml"
    if [[ -f "$compose_file" ]]; then
        cd "$(dirname "$compose_file")"
        docker compose pull >/dev/null 2>&1 || true
        docker compose up -d >/dev/null 2>&1 || true
    fi

    # Clean old images
    docker image prune -f >/dev/null 2>&1 || true

    log_success "Docker image updates completed"
}

# Health check and monitoring
perform_health_check() {
    log_debug "Performing maintenance health check"

    local issues=()

    # Check disk space
    local disk_usage
    disk_usage=$(df /opt/vless | awk 'NR==2{print $5}' | sed 's/%//')
    if [[ $disk_usage -gt $DISK_CLEANUP_THRESHOLD ]]; then
        issues+=("High disk usage: $disk_usage%")
    fi

    # Check memory usage
    local memory_usage
    memory_usage=$(free | awk 'NR==2{printf "%.0f", $3*100/$2}')
    if [[ $memory_usage -gt 90 ]]; then
        issues+=("High memory usage: $memory_usage%")
    fi

    # Check for required reboot
    if [[ -f /var/run/reboot-required ]]; then
        issues+=("System reboot required")
    fi

    # Check VLESS services
    if ! systemctl is-active vless-vpn >/dev/null 2>&1; then
        issues+=("VLESS service not running")
    fi

    # Check Docker services
    if command_exists docker; then
        local vless_containers
        vless_containers=$(docker ps --filter "name=vless" --format "{{.Names}}" | wc -l)
        if [[ $vless_containers -eq 0 ]]; then
            issues+=("No VLESS containers running")
        fi
    fi

    # Report issues
    if [[ ${#issues[@]} -gt 0 ]]; then
        log_warn "Health check found ${#issues[@]} issues:"
        printf "  %s\n" "${issues[@]}"
        return 1
    else
        log_success "Health check passed - no issues found"
        return 0
    fi
}

# Complete maintenance routine
run_maintenance_routine() {
    local maintenance_type="${1:-full}"

    log_info "Starting maintenance routine (type: $maintenance_type)"

    local start_time
    start_time=$(date +%s)

    # Create maintenance log entry
    local maintenance_log="${MAINTENANCE_LOG_DIR}/maintenance_$(date +%Y%m%d).log"
    {
        echo "=== VLESS Maintenance Routine ==="
        echo "Type: $maintenance_type"
        echo "Started: $(get_timestamp)"
        echo "User: $(whoami)"
        echo ""
    } >> "$maintenance_log"

    local tasks_completed=0
    local tasks_failed=0

    # Define maintenance tasks based on type
    case "$maintenance_type" in
        "full")
            local tasks=(
                "perform_health_check"
                "perform_system_updates security"
                "perform_log_cleanup"
                "perform_docker_cleanup"
                "perform_database_optimization"
                "perform_disk_cleanup"
                "perform_performance_tuning"
                "update_docker_images"
            )
            ;;
        "light")
            local tasks=(
                "perform_health_check"
                "perform_log_cleanup"
                "perform_docker_cleanup"
            )
            ;;
        "security")
            local tasks=(
                "perform_system_updates security"
                "perform_database_optimization"
                "perform_health_check"
            )
            ;;
        *)
            log_error "Invalid maintenance type: $maintenance_type"
            return 1
            ;;
    esac

    # Execute maintenance tasks
    local task
    for task in "${tasks[@]}"; do
        log_info "Executing task: $task"
        {
            echo "Task: $task"
            echo "Started: $(get_timestamp)"
        } >> "$maintenance_log"

        if eval "$task" >> "$maintenance_log" 2>&1; then
            log_success "Task completed: $task"
            ((tasks_completed++))
            echo "Status: SUCCESS" >> "$maintenance_log"
        else
            log_error "Task failed: $task"
            ((tasks_failed++))
            echo "Status: FAILED" >> "$maintenance_log"
        fi

        echo "Completed: $(get_timestamp)" >> "$maintenance_log"
        echo "" >> "$maintenance_log"
    done

    # Calculate duration
    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))

    # Final summary
    {
        echo "=== Maintenance Summary ==="
        echo "Completed: $(get_timestamp)"
        echo "Duration: ${duration}s"
        echo "Tasks completed: $tasks_completed"
        echo "Tasks failed: $tasks_failed"
        echo ""
    } >> "$maintenance_log"

    log_success "Maintenance routine completed in ${duration}s"
    log_info "Tasks completed: $tasks_completed, failed: $tasks_failed"
    log_info "Maintenance log: $maintenance_log"

    # Send notification if configured
    send_maintenance_notification "$maintenance_type" "$tasks_completed" "$tasks_failed" "$duration"

    return $tasks_failed
}

# Send maintenance notification
send_maintenance_notification() {
    local maintenance_type="$1"
    local completed="$2"
    local failed="$3"
    local duration="$4"

    local status="SUCCESS"
    if [[ $failed -gt 0 ]]; then
        status="WARNING"
    fi

    log_info "Maintenance notification: $status - Type: $maintenance_type, Completed: $completed, Failed: $failed"

    # Log notification
    echo "[$(get_timestamp)] MAINTENANCE [$status] Type: $maintenance_type, Duration: ${duration}s, Completed: $completed, Failed: $failed" >> "${MAINTENANCE_LOG_DIR}/maintenance_notifications.log"

    # TODO: Implement email/webhook notifications
    # send_email_notification "$status" "$maintenance_type" "$completed" "$failed" "$duration"
    # send_webhook_notification "$status" "$maintenance_type" "$completed" "$failed" "$duration"
}

# Schedule maintenance tasks
schedule_maintenance_tasks() {
    log_info "Scheduling maintenance tasks"

    # Create maintenance script
    local maintenance_script="${MAINTENANCE_CONFIG_DIR}/auto_maintenance.sh"

    cat > "$maintenance_script" << 'EOF'
#!/bin/bash
# VLESS Automatic Maintenance Script

set -euo pipefail

# Import maintenance module
SOURCE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../modules" && pwd)"
source "${SOURCE_DIR}/maintenance_utils.sh"

# Load configuration
MAINTENANCE_CONFIG="${MAINTENANCE_CONFIG_DIR}/maintenance.conf"
if [[ -f "$MAINTENANCE_CONFIG" ]]; then
    source "$MAINTENANCE_CONFIG"
fi

# Determine maintenance type based on day of week
CURRENT_DAY=$(date +%A | tr '[:upper:]' '[:lower:]')

case "$CURRENT_DAY" in
    "sunday")
        # Full maintenance on Sunday
        run_maintenance_routine "full"
        ;;
    "wednesday")
        # Security updates on Wednesday
        run_maintenance_routine "security"
        ;;
    *)
        # Light maintenance on other days
        run_maintenance_routine "light"
        ;;
esac

EOF

    chmod 755 "$maintenance_script"
    chown root:root "$maintenance_script"

    # Create systemd service and timer
    cat > "/etc/systemd/system/vless-maintenance.service" << EOF
[Unit]
Description=VLESS Automatic Maintenance
After=vless-vpn.service

[Service]
Type=oneshot
User=root
Group=root
ExecStart=$maintenance_script
StandardOutput=journal
StandardError=journal

EOF

    cat > "/etc/systemd/system/vless-maintenance.timer" << EOF
[Unit]
Description=VLESS Maintenance Timer
Requires=vless-maintenance.service

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target

EOF

    # Enable and start timer
    systemctl daemon-reload
    isolate_systemctl_command "enable" "vless-maintenance.timer" 30
    isolate_systemctl_command "start" "vless-maintenance.timer" 30

    log_success "Maintenance tasks scheduling configured"
}

# Main function for command line usage
main() {
    case "${1:-help}" in
        "init")
            init_maintenance_utils
            ;;
        "routine")
            run_maintenance_routine "${2:-full}"
            ;;
        "updates")
            perform_system_updates "${2:-security}" "${3:-false}"
            ;;
        "cleanup")
            case "${2:-all}" in
                "logs") perform_log_cleanup "${3:-30}" ;;
                "docker") perform_docker_cleanup ;;
                "disk") perform_disk_cleanup "${3:-80}" ;;
                "all"|*)
                    perform_log_cleanup
                    perform_docker_cleanup
                    perform_disk_cleanup
                    ;;
            esac
            ;;
        "optimize")
            case "${2:-all}" in
                "database") perform_database_optimization ;;
                "performance") perform_performance_tuning ;;
                "all"|*)
                    perform_database_optimization
                    perform_performance_tuning
                    ;;
            esac
            ;;
        "update-images")
            update_docker_images
            ;;
        "health-check")
            perform_health_check
            ;;
        "schedule")
            schedule_maintenance_tasks
            ;;
        "help"|*)
            echo "VLESS Maintenance Utilities Usage:"
            echo "  $0 init                              - Initialize maintenance utilities"
            echo "  $0 routine [full|light|security]    - Run maintenance routine"
            echo "  $0 updates [security|all|dist] [auto-reboot] - Perform system updates"
            echo "  $0 cleanup [logs|docker|disk|all] [params] - Cleanup operations"
            echo "  $0 optimize [database|performance|all] - Optimization tasks"
            echo "  $0 update-images                     - Update Docker images"
            echo "  $0 health-check                      - Perform health check"
            echo "  $0 schedule                          - Schedule automatic maintenance"
            ;;
    esac
}

# Export functions
export -f init_maintenance_utils create_maintenance_config acquire_maintenance_lock
export -f release_maintenance_lock perform_system_updates perform_log_cleanup
export -f perform_docker_cleanup perform_database_optimization perform_disk_cleanup
export -f perform_performance_tuning update_docker_images perform_health_check
export -f run_maintenance_routine schedule_maintenance_tasks send_maintenance_notification

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi

log_debug "Maintenance utilities module loaded successfully"