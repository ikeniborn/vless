version: "1.0"
documentation_version: "v5.26"
last_updated: "2026-01-07"

project:
  name: "familyTraffic VPN - Data Flow Architecture"
  version: "v5.26"
  description: "Comprehensive documentation of all data flows, traffic routing patterns, and state transitions"

data_flows:
  vless_reality_flow:
    name: "VLESS Reality Protocol Traffic Flow"
    protocol: "VLESS over Reality (TLS 1.3 masquerading)"
    entry_point: "Client connects to server:443"
    purpose: "Primary VPN connection flow with DPI resistance"
    encryption: "TLS 1.3 (Reality protocol mimics legitimate HTTPS)"

    steps:
      - stage: "Client Initiation"
        component: "Client Device"
        action: "Initiates TLS 1.3 connection to server:443"
        protocol: "VLESS Reality"
        client_hello:
          sni: "${VLESS_DOMAIN}"
          fingerprint: "Chrome/Firefox TLS fingerprint (mimics real browser)"
        data_transmitted:
          - "TLS 1.3 ClientHello with SNI"
          - "Reality protocol handshake data"

      - stage: "HAProxy SNI Inspection"
        component: "familytraffic-haproxy"
        port: 443
        action: "Inspects SNI (Server Name Indication) without decrypting TLS"
        inspection_method: "TCP request content inspection"
        acl_check: "req_ssl_sni -i ${VLESS_DOMAIN}"

        decision_tree:
          if_sni_matches_vless_domain:
            condition: "SNI == ${VLESS_DOMAIN}"
            backend: "xray_vless"
            action: "Passthrough to Xray:8443 (NO TLS decryption)"
            target: "127.0.0.1:8443"

          if_sni_matches_reverse_proxy:
            condition: "SNI == reverse proxy subdomain (dynamic ACL)"
            backend: "nginx_<subdomain>"
            action: "TLS passthrough to Nginx reverse proxy"
            target: "127.0.0.1:9443-9452"

          if_sni_unknown:
            condition: "SNI not recognized"
            backend: "fake_site_fallback"
            action: "Route to fake nginx site"
            target: "familytraffic-fake-site:80"
            purpose: "Anti-detection camouflage"

        data_forwarded:
          - "Entire TLS stream (encrypted, unmodified)"
          - "No packet inspection or modification"

      - stage: "Xray VLESS Reality Processing"
        component: "familytraffic"
        port: 8443
        listen: "127.0.0.1"
        action: "Reality protocol handshake and UUID authentication"

        reality_handshake:
          tls_destination: "www.microsoft.com:443"
          action: "Mimics legitimate TLS connection to microsoft.com"
          fingerprint_validation: "Validates client TLS fingerprint"
          server_name_validation: "Validates SNI matches configured serverNames"

        authentication:
          method: "UUID-based"
          validation_source: "/opt/familytraffic/config/xray_config.json clients[]"
          checks:
            - "Validate UUID exists in clients[] list"
            - "Validate Reality TLS fingerprint matches"
            - "Validate flow setting (xtls-rprx-vision)"

        on_success:
          action: "Proceed to Routing Decision"
          client_state: "Authenticated"

        on_failure:
          action: "Fallback to familytraffic-fake-site:80"
          client_state: "Unauthenticated"
          purpose: "Hide VPN infrastructure from probing attacks"
          response: "Returns fake nginx website (appears as HTTP site)"

        data_decrypted:
          - "Inner VLESS protocol payload"
          - "Destination address and port"
          - "Application data (HTTP, HTTPS, etc.)"

      - stage: "Routing Decision"
        component: "familytraffic"
        section: "routing.rules[]"
        action: "Determine outbound based on user configuration"

        routing_logic:
          rule_1_per_user_external_proxy:
            priority: 1
            feature_version: "v5.24+"
            condition: "users[uuid].external_proxy_id != null"
            check:
              source: "/opt/familytraffic/data/users.json"
              field: "users[].external_proxy_id"
              example: "users[].email == 'alice@vless.local' && external_proxy_id == 'proxy-1'"
            outbound: "external-proxy"
            description: "Route through upstream SOCKS5/HTTPS proxy"
            next_stage: "External Proxy Chain"

          rule_2_default_direct:
            priority: 2
            condition: "users[uuid].external_proxy_id == null OR not matched by rule 1"
            outbound: "direct"
            description: "Direct internet access (no upstream proxy)"
            next_stage: "Direct Internet Access"

        data_analyzed:
          - "User email/UUID (from authentication)"
          - "Destination domain/IP"
          - "Protocol type (from sniffing)"

      - stage: "External Proxy Chain (Optional)"
        component: "familytraffic → External Proxy Server"
        condition: "external_proxy_id is set for user"
        feature_version: "v5.24+"

        proxy_connection:
          protocol: "SOCKS5 or SOCKS5s or HTTP or HTTPS"
          target:
            source: "/opt/familytraffic/config/external_proxy.json"
            fields: "proxies[].address, proxies[].port"
          authentication:
            source: "/opt/familytraffic/config/external_proxy.json"
            fields: "proxies[].username, proxies[].password"
          tls:
            enabled: "If protocol == socks5s or https"
            validation: "Upstream proxy TLS certificate validation"

        retry_logic:
          max_attempts: 3
          backoff: "Exponential (1s, 2s, 4s)"
          on_failure: "Fallback to direct outbound (warn user)"

        data_transmitted:
          - "Application data encrypted by upstream proxy protocol"
          - "Destination address via SOCKS5/HTTP CONNECT"

      - stage: "Direct Internet Access"
        component: "familytraffic → Internet"
        condition: "No external proxy configured OR external proxy failed"
        outbound: "direct (freedom protocol)"

        connection:
          method: "Direct TCP/UDP connection to destination"
          source_ip: "VPN server public IP"

        data_transmitted:
          - "Application data (HTTP, HTTPS, etc.)"
          - "Destination sees VPN server IP as source"

      - stage: "Internet Destination"
        component: "Target Website/Service"

        ip_visible_to_destination:
          if_external_proxy_used:
            visible_ip: "External proxy server IP"
            chain: "Client → VPN Server → External Proxy → Destination"

          if_direct_access:
            visible_ip: "VPN server IP"
            chain: "Client → VPN Server → Destination"

        data_received:
          - "Application request (HTTP GET, TLS handshake, etc.)"
          - "Source IP: VPN server or external proxy"

      - stage: "Return Path"
        component: "Internet → familytraffic → HAProxy → Client"
        action: "Response data follows reverse path"

        flow:
          - "Destination → (External Proxy) → Xray"
          - "Xray encrypts with VLESS Reality"
          - "Xray → HAProxy (TLS passthrough)"
          - "HAProxy → Client:443"

    performance:
      latency_overhead: "< 10ms (Reality protocol + routing)"
      throughput: "Limited by VPN server bandwidth and external proxy (if used)"
      encryption_overhead: "Minimal (TLS 1.3 hardware acceleration)"

    security:
      dpi_resistance: "HIGH (Reality protocol mimics legitimate TLS)"
      traffic_analysis_resistance: "HIGH (appears as HTTPS to www.microsoft.com)"
      authentication: "UUID-based (strong, unique per user)"
      encryption: "TLS 1.3 (modern, secure)"

    diagram_reference: "diagrams/data-flows/vless-reality-flow.md"

  socks5_proxy_flow:
    name: "SOCKS5 over TLS Proxy Traffic Flow"
    protocol: "SOCKS5 protocol with TLS encryption"
    entry_point: "Client connects to server:1080 (socks5s://)"
    purpose: "Secure SOCKS5 proxy with TLS termination at HAProxy"
    encryption: "TLS 1.3 (Let's Encrypt certificate)"

    steps:
      - stage: "Client TLS Connection"
        component: "Client Device"
        action: "Initiates TLS 1.3 connection to server:1080"
        protocol: "SOCKS5 over TLS (socks5s://)"
        uri_format: "socks5s://username:password@server:1080"
        client_hello:
          sni: "${DOMAIN}"
          alpn: "h2, http/1.1"

        data_transmitted:
          - "TLS 1.3 ClientHello"
          - "SOCKS5 request (encrypted within TLS)"

      - stage: "HAProxy TLS Termination"
        component: "familytraffic-haproxy"
        port: 1080
        action: "Decrypt TLS 1.3 with Let's Encrypt certificate"

        tls_termination:
          certificate: "/etc/letsencrypt/live/${DOMAIN}/combined.pem"
          protocol: "TLS 1.3"
          cipher_suites: "Modern TLS 1.3 ciphers (AES-GCM, ChaCha20-Poly1305)"
          backend: "xray_socks5_plaintext"
          target: "127.0.0.1:10800"

        decrypted_payload:
          - "SOCKS5 request (plaintext)"
          - "Username and password (plaintext, internal network only)"
          - "Destination address and port"

        data_forwarded:
          - "Plaintext SOCKS5 request to Xray:10800"
          - "No encryption between HAProxy and Xray (localhost only)"

      - stage: "Xray SOCKS5 Authentication"
        component: "familytraffic"
        port: 10800
        listen: "127.0.0.1"
        protocol: "SOCKS5 (plaintext inbound)"

        authentication:
          method: "Username + password"
          source: "/opt/familytraffic/config/xray_config.json"
          validation:
            - "accounts[].user == provided username"
            - "accounts[].pass == provided password (UUID from users.json)"
          accounts_mapping:
            source: "/opt/familytraffic/data/users.json"
            transformation: "users[].username → accounts[].user, users[].uuid → accounts[].pass"

        on_success:
          action: "Proceed to Routing & Proxying"
          client_state: "Authenticated"

        on_failure:
          action: "Close connection"
          response: "SOCKS5 authentication failure"
          client_state: "Rejected"

      - stage: "SOCKS5 Protocol Handling"
        component: "familytraffic"
        action: "Parse SOCKS5 request and establish connection"

        socks5_handshake:
          - "Client sends SOCKS5 version negotiation"
          - "Xray responds with authentication method (username/password)"
          - "Client sends username/password"
          - "Xray validates and responds"
          - "Client sends connection request (CONNECT command)"
          - "Xray establishes connection to destination"

        data_parsed:
          - "Destination address (domain or IP)"
          - "Destination port"
          - "Command type (CONNECT, BIND, UDP ASSOCIATE)"

      - stage: "Routing & External Proxy (Optional)"
        component: "familytraffic routing"
        action: "Route based on user configuration (same as VLESS flow)"

        routing_logic:
          per_user_proxy:
            condition: "users[username].external_proxy_id != null"
            outbound: "external-proxy"
            feature_version: "v5.24+"

          default_direct:
            condition: "users[username].external_proxy_id == null"
            outbound: "direct"

        data_routed:
          - "Application data (HTTP, HTTPS, etc.)"
          - "Via external proxy OR direct"

      - stage: "Internet Destination"
        component: "Target Service"

        connection:
          source_ip:
            if_external_proxy: "External proxy IP"
            if_direct: "VPN server IP"

        data_received:
          - "Application protocol data"
          - "Source IP: VPN server or external proxy"

      - stage: "Return Path"
        component: "Internet → Xray → HAProxy → Client"
        action: "Response data follows reverse path"

        flow:
          - "Destination → (External Proxy) → Xray:10800 (plaintext)"
          - "Xray → HAProxy:1080 (plaintext)"
          - "HAProxy encrypts with TLS 1.3"
          - "HAProxy → Client:1080 (encrypted)"

    performance:
      latency_overhead: "< 5ms (TLS termination + SOCKS5 parsing)"
      throughput: "Limited by VPN server bandwidth"
      encryption_overhead: "TLS 1.3 encryption/decryption at HAProxy"

    security:
      transport_security: "TLS 1.3 (client to HAProxy)"
      authentication: "Username + password (UUID)"
      internal_plaintext: "HAProxy to Xray (localhost only, acceptable)"
      certificate_validation: "Let's Encrypt trusted certificate"

    diagram_reference: "diagrams/data-flows/socks5-proxy-flow.md"

  http_proxy_flow:
    name: "HTTP Proxy over TLS Traffic Flow"
    protocol: "HTTP CONNECT proxy with TLS encryption"
    entry_point: "Client connects to server:8118"
    purpose: "Secure HTTP proxy with TLS termination at HAProxy"
    encryption: "TLS 1.3 (Let's Encrypt certificate)"

    steps:
      - stage: "Client TLS Connection"
        component: "Client Device"
        action: "Initiates TLS 1.3 connection to server:8118"
        protocol: "HTTP proxy over TLS"
        proxy_configuration:
          http_proxy: "https://username:password@server:8118"
          https_proxy: "https://username:password@server:8118"

        data_transmitted:
          - "TLS 1.3 ClientHello"
          - "HTTP CONNECT request (encrypted within TLS)"

      - stage: "HAProxy TLS Termination"
        component: "familytraffic-haproxy"
        port: 8118
        action: "Decrypt TLS 1.3 with Let's Encrypt certificate"

        tls_termination:
          certificate: "/etc/letsencrypt/live/${DOMAIN}/combined.pem"
          protocol: "TLS 1.3"
          backend: "xray_http_plaintext"
          target: "127.0.0.1:18118"

        decrypted_payload:
          - "HTTP CONNECT request (plaintext)"
          - "Proxy-Authorization header (username:password base64)"
          - "Destination host and port"

        data_forwarded:
          - "Plaintext HTTP CONNECT to Xray:18118"
          - "No encryption between HAProxy and Xray (localhost only)"

      - stage: "Xray HTTP Proxy Authentication"
        component: "familytraffic"
        port: 18118
        listen: "127.0.0.1"
        protocol: "HTTP proxy (plaintext inbound)"

        authentication:
          method: "HTTP Basic Authentication (Proxy-Authorization header)"
          source: "/opt/familytraffic/config/xray_config.json"
          validation:
            - "accounts[].user == decoded username"
            - "accounts[].pass == decoded password (UUID)"
          accounts_mapping:
            source: "/opt/familytraffic/data/users.json"
            transformation: "users[].username → accounts[].user, users[].uuid → accounts[].pass"

        on_success:
          action: "Proceed to HTTP CONNECT tunnel"
          response: "HTTP/1.1 200 Connection Established"

        on_failure:
          action: "Close connection"
          response: "HTTP/1.1 407 Proxy Authentication Required"

      - stage: "HTTP CONNECT Tunnel"
        component: "familytraffic"
        action: "Establish TCP tunnel to destination"

        connect_method:
          - "Client sends: CONNECT example.com:443 HTTP/1.1"
          - "Xray validates authentication"
          - "Xray establishes connection to example.com:443"
          - "Xray responds: HTTP/1.1 200 Connection Established"
          - "Bidirectional tunnel established"

        data_tunneled:
          - "Raw TCP data (typically TLS for HTTPS)"
          - "No inspection or modification by Xray"

      - stage: "Routing & External Proxy (Optional)"
        component: "familytraffic routing"
        action: "Route based on user configuration (same as VLESS/SOCKS5)"

        routing_logic:
          per_user_proxy:
            condition: "users[username].external_proxy_id != null"
            outbound: "external-proxy"
            feature_version: "v5.24+"

          default_direct:
            condition: "users[username].external_proxy_id == null"
            outbound: "direct"

      - stage: "Internet Destination"
        component: "Target Website"

        connection:
          protocol: "Usually TLS (HTTPS) inside HTTP CONNECT tunnel"
          source_ip:
            if_external_proxy: "External proxy IP"
            if_direct: "VPN server IP"

      - stage: "Return Path"
        component: "Internet → Xray → HAProxy → Client"
        action: "Response data follows reverse path through tunnel"

        flow:
          - "Destination → (External Proxy) → Xray:18118 (plaintext)"
          - "Xray → HAProxy:8118 (plaintext)"
          - "HAProxy encrypts with TLS 1.3"
          - "HAProxy → Client:8118 (encrypted)"

    performance:
      latency_overhead: "< 5ms (TLS termination + HTTP parsing)"
      throughput: "Limited by VPN server bandwidth"
      encryption_overhead: "TLS 1.3 encryption/decryption at HAProxy"

    security:
      transport_security: "TLS 1.3 (client to HAProxy)"
      authentication: "HTTP Basic Auth with UUID password"
      internal_plaintext: "HAProxy to Xray (localhost only)"
      tunnel_contents: "Not inspected (end-to-end encryption preserved)"

    diagram_reference: "diagrams/data-flows/http-proxy-flow.md"

  reverse_proxy_flow:
    name: "Reverse Proxy Subdomain Traffic Flow"
    protocol: "HTTPS (TLS 1.3)"
    entry_point: "Client connects to https://subdomain.example.com:443"
    purpose: "Subdomain-based reverse proxy without port numbers"
    encryption: "TLS 1.3 (Let's Encrypt per-domain certificates)"

    steps:
      - stage: "Client HTTPS Connection"
        component: "Client Browser"
        action: "Initiates HTTPS connection to subdomain"
        url_format: "https://subdomain.example.com/ (NO port number!)"
        client_hello:
          sni: "subdomain.example.com"
          alpn: "h2, http/1.1"

        data_transmitted:
          - "TLS 1.3 ClientHello with SNI"
          - "HTTP request (encrypted)"

      - stage: "HAProxy SNI Routing"
        component: "familytraffic-haproxy"
        port: 443
        action: "Route based on SNI without decrypting TLS"

        acl_matching:
          dynamic_acls:
            source: "DYNAMIC_REVERSE_PROXY_ROUTES section in haproxy.cfg"
            format: "acl is_<sanitized_domain> req.ssl_sni -i subdomain.example.com"
            example: "acl is_claude_example_com req.ssl_sni -i claude.example.com"

          backend_selection:
            pattern: "use_backend nginx_<sanitized_domain> if is_<sanitized_domain>"
            example: "use_backend nginx_claude_example_com if is_claude_example_com"
            target: "127.0.0.1:9443 (or 9444-9452, one port per domain)"

        tls_handling: "Passthrough (NO decryption at HAProxy)"

        data_forwarded:
          - "Entire TLS stream (encrypted) to Nginx reverse proxy"
          - "SNI-based routing only"

      - stage: "Nginx TLS Termination"
        component: "familytraffic-nginx"
        port_range: "9443-9452"
        action: "Decrypt TLS with per-domain Let's Encrypt certificate"

        tls_termination:
          certificate: "/etc/letsencrypt/live/subdomain.example.com/fullchain.pem"
          certificate_key: "/etc/letsencrypt/live/subdomain.example.com/privkey.pem"
          protocol: "TLS 1.3, TLS 1.2"
          cipher_suites: "Modern ciphers only (HIGH:!aNULL:!MD5)"

        decrypted_payload:
          - "HTTP request (GET, POST, etc.)"
          - "Request headers"
          - "Request body"

      - stage: "Nginx Reverse Proxy Processing"
        component: "familytraffic-nginx"
        action: "Process request and proxy to upstream target"

        request_processing:
          rate_limiting:
            zone: "reverseproxy_<sanitized_domain>"
            rate: "Configurable (default 100r/s)"
            burst: "Configurable (default 20)"
            action_on_limit: "Return 429 Too Many Requests"

          header_modification:
            - "Set Host: <target_host> (upstream destination)"
            - "Set X-Real-IP: <client_ip>"
            - "Set X-Forwarded-For: <client_ip>"
            - "Set X-Forwarded-Proto: https"
            - "Set Upgrade: $http_upgrade (for WebSocket)"
            - "Set Connection: $connection_upgrade (for WebSocket)"

          optional_features:
            oauth2:
              enabled: "Per-domain configuration"
              action: "auth_request directive to OAuth2 provider"

            websocket:
              enabled: "Auto-detect via Upgrade header"
              action: "Preserve WebSocket upgrade requests"

            csp:
              enabled: "Per-domain configuration"
              action: "Add Content-Security-Policy headers"

        proxy_pass:
          target:
            source: "/opt/familytraffic/config/reverse-proxy/<domain>.conf"
            directive: "proxy_pass <target_url>;"
            example: "proxy_pass https://claude.ai;"

          connection:
            protocol: "HTTPS (typically, configurable)"
            ssl_verify: "none (Nginx doesn't verify upstream SSL)"
            timeout: "60s (connect, send, read)"

      - stage: "Upstream Target"
        component: "Target Website (e.g., claude.ai, github.com)"
        action: "Receives proxied request"

        request_received:
          headers:
            host: "claude.ai (target host)"
            x_real_ip: "Client IP (via X-Real-IP header)"
            x_forwarded_for: "Client IP"
            x_forwarded_proto: "https"

          source_ip: "VPN server IP (as seen by target)"

        data_processed:
          - "HTTP request from Nginx reverse proxy"
          - "Target processes normally"

      - stage: "Return Path"
        component: "Target → Nginx → HAProxy → Client"
        action: "Response data follows reverse path"

        flow:
          - "Target → Nginx (HTTPS, unverified SSL)"
          - "Nginx receives response"
          - "Nginx encrypts with subdomain TLS certificate"
          - "Nginx → HAProxy:9443 (TLS)"
          - "HAProxy → Client:443 (TLS passthrough)"

        response_processing:
          - "Nginx may add custom headers (HSTS, CSP, etc.)"
          - "Nginx logs request/response"
          - "Rate limit counters updated"

    performance:
      latency_overhead: "< 15ms (SNI routing + TLS termination + proxy)"
      throughput: "Limited by VPN server bandwidth and rate limiting"
      concurrent_domains: "Maximum 10 (port slots 9443-9452)"

    security:
      transport_security:
        client_to_haproxy: "TLS 1.3 passthrough"
        haproxy_to_nginx: "TLS (localhost, but encrypted)"
        nginx_to_target: "HTTPS (typically)"
      authentication: "Optional (OAuth2 per domain)"
      rate_limiting: "Mandatory (prevents abuse)"
      certificate_validation: "Let's Encrypt trusted certificates"

    diagram_reference: "diagrams/data-flows/reverse-proxy-flow.md"

  external_proxy_flow:
    name: "External Proxy Chaining Traffic Flow (v5.24+)"
    protocol: "VLESS/SOCKS5/HTTP → External SOCKS5/HTTPS → Internet"
    entry_point: "Client connects via VLESS/SOCKS5/HTTP (any protocol)"
    purpose: "Per-user upstream proxy routing for advanced privacy"
    feature_version: "v5.24+"
    encryption: "Multi-layer (Client TLS + External proxy TLS if socks5s/https)"

    steps:
      - stage: "Client Connection (Any Protocol)"
        component: "Client Device"
        action: "Connects via VLESS, SOCKS5, or HTTP proxy"
        protocols_supported:
          - "VLESS Reality (port 443)"
          - "SOCKS5 over TLS (port 1080)"
          - "HTTP proxy over TLS (port 8118)"

        user_configuration:
          source: "/opt/familytraffic/data/users.json"
          field: "users[].external_proxy_id"
          example: "alice has external_proxy_id = 'proxy-1'"

        data_transmitted:
          - "Application data (HTTP, HTTPS, etc.)"
          - "Via selected VPN protocol"

      - stage: "HAProxy & Xray Processing"
        component: "familytraffic-haproxy → familytraffic"
        action: "Standard VPN processing (same as previous flows)"

        processing:
          - "HAProxy routes based on SNI/port"
          - "Xray authenticates user (UUID or username/password)"
          - "Xray decrypts VPN tunnel"

        user_identification:
          vless: "users[].email (email@vless.local)"
          socks5_http: "users[].username"

      - stage: "Xray Routing Decision with External Proxy"
        component: "familytraffic routing engine"
        action: "Check user's external_proxy_id and route accordingly"

        routing_rule_evaluation:
          rule_1_per_user_proxy:
            priority: 1
            type: "field"
            condition: "user in routing.rules[].user[] array"
            source:
              users_json: "/opt/familytraffic/data/users.json"
              field: "users[].external_proxy_id != null"
            generator: "lib/xray_routing_manager.sh::update_xray_routing_for_user()"

            user_array:
              format: "['alice@vless.local', 'bob@vless.local', ...]"
              dynamic: "Regenerated on every set-proxy command"

            outbound: "external-proxy"
            action: "Route to upstream proxy"

          rule_2_default:
            priority: 2
            condition: "User not in rule 1 user array"
            outbound: "direct"
            action: "Direct internet access (no upstream proxy)"

        data_analyzed:
          - "User identifier (email or username)"
          - "Destination address"
          - "Protocol type"

      - stage: "External Proxy Connection"
        component: "familytraffic → External Proxy Server"
        action: "Establish connection to upstream proxy"

        proxy_configuration:
          source: "/opt/familytraffic/config/external_proxy.json"
          lookup: "proxies[].id == users[].external_proxy_id"
          fields_used:
            - "proxies[].address (proxy server IP/domain)"
            - "proxies[].port (proxy server port)"
            - "proxies[].protocol (socks5, socks5s, http, https)"
            - "proxies[].username (proxy auth username)"
            - "proxies[].password (proxy auth password)"

        proxy_protocols:
          socks5:
            description: "SOCKS5 plaintext (not recommended)"
            port: "Typically 1080"
            authentication: "Username + password"
            encryption: "None"

          socks5s:
            description: "SOCKS5 over TLS (recommended)"
            port: "Typically 1080"
            authentication: "Username + password"
            encryption: "TLS (validates upstream certificate)"

          http:
            description: "HTTP CONNECT plaintext (not recommended)"
            port: "Typically 8080"
            authentication: "HTTP Basic Auth"
            encryption: "None"

          https:
            description: "HTTP CONNECT over TLS (recommended)"
            port: "Typically 8118"
            authentication: "HTTP Basic Auth"
            encryption: "TLS (validates upstream certificate)"

        connection_establishment:
          - "Xray connects to proxy server"
          - "If socks5s/https: TLS handshake"
          - "Proxy authentication (username/password)"
          - "Send destination address via SOCKS5/HTTP CONNECT"
          - "Proxy establishes connection to destination"

        retry_logic:
          max_attempts: 3
          backoff: "Exponential (1s, 2s, 4s)"
          on_all_failures: "Fallback to direct outbound (log warning)"

        data_transmitted:
          - "Destination address and port"
          - "Application data (encrypted by proxy protocol if socks5s/https)"

      - stage: "External Proxy Routing"
        component: "External Proxy Server"
        action: "Forward traffic to internet destination"

        proxy_server_processing:
          - "Receives connection from VPN server"
          - "Authenticates VPN server (username/password)"
          - "Establishes connection to destination"
          - "Forwards bidirectional traffic"

        logging:
          - "Proxy server logs VPN server IP as source"
          - "Proxy server logs destination address"
          - "Application of proxy's own routing rules"

      - stage: "Internet Destination"
        component: "Target Website/Service"
        action: "Receives request from external proxy"

        visible_source:
          ip: "External proxy server IP (NOT VPN server, NOT client)"
          chain: "Client → VPN Server → External Proxy → Destination"

        privacy_benefit:
          - "Destination doesn't see VPN server IP"
          - "VPN server and external proxy IPs are separate"
          - "Enhanced anonymity via IP chain"

        data_received:
          - "Application protocol data (HTTP, HTTPS, etc.)"
          - "Source IP: External proxy server"

      - stage: "Return Path"
        component: "Internet → External Proxy → Xray → HAProxy → Client"
        action: "Response data follows reverse path"

        flow:
          - "Destination → External Proxy"
          - "External Proxy → Xray:external-proxy outbound (socks5s/https encrypted)"
          - "Xray → HAProxy (protocol-dependent)"
          - "HAProxy → Client (encrypted)"

        multi_layer_encryption:
          vless_client:
            - "Layer 1: HTTPS response from destination"
            - "Layer 2: External proxy encryption (if socks5s/https)"
            - "Layer 3: VLESS Reality encryption"

          socks5_http_client:
            - "Layer 1: HTTPS response from destination"
            - "Layer 2: External proxy encryption (if socks5s/https)"
            - "Layer 3: TLS encryption (HAProxy)"

    configuration_management:
      add_external_proxy:
        command: "sudo familytraffic-external-proxy add"
        affected_files:
          - "/opt/familytraffic/config/external_proxy.json (add proxy record)"
          - "/opt/familytraffic/config/xray_config.json (update outbounds)"
        service_restart: "familytraffic (full restart)"

      assign_proxy_to_user:
        command: "sudo familytraffic set-proxy <username> <proxy-id>"
        affected_files:
          - "/opt/familytraffic/data/users.json (set external_proxy_id)"
          - "/opt/familytraffic/config/xray_config.json (update routing.rules)"
        service_reload: "familytraffic (SIGHUP - graceful)"

      remove_proxy_from_user:
        command: "sudo familytraffic set-proxy <username> none"
        affected_files:
          - "/opt/familytraffic/data/users.json (set external_proxy_id = null)"
          - "/opt/familytraffic/config/xray_config.json (update routing.rules)"
        service_reload: "familytraffic (SIGHUP - graceful)"

    performance:
      latency_overhead: "50-200ms (depends on external proxy location)"
      throughput: "Limited by external proxy bandwidth"
      additional_hop: "Adds one network hop (VPN → Proxy)"

    security:
      multi_layer_encryption:
        client_to_vpn: "VLESS Reality or TLS 1.3"
        vpn_to_proxy: "socks5s or https (recommended)"
        proxy_to_destination: "HTTPS (typically)"
      privacy_enhancement: "Destination sees proxy IP, not VPN IP"
      trust_requirement: "External proxy must be trusted (can see all traffic)"

    diagram_reference: "diagrams/data-flows/external-proxy-flow.md"

state_transition_flows:
  user_management_add_user:
    name: "Add User State Transition Flow"
    trigger: "sudo familytraffic add-user <username>"
    purpose: "Create new VPN user with client configurations"

    state_changes:
      - file: "/opt/familytraffic/data/users.json"
        before:
          users: "['existing_user1', 'existing_user2']"
        after:
          users: "['existing_user1', 'existing_user2', 'new_user']"
        operation: "append user object"
        locking: "flock /var/lock/familytraffic_users.lock"
        atomic_write: true

      - file: "/opt/familytraffic/config/xray_config.json"
        before:
          inbounds_vless_clients: "[{id: 'uuid1', email: 'user1@vless.local'}, ...]"
          inbounds_socks_accounts: "[{user: 'user1', pass: 'uuid1'}, ...]"
        after:
          inbounds_vless_clients: "[..., {id: 'new_uuid', email: 'new_user@vless.local'}]"
          inbounds_socks_accounts: "[..., {user: 'new_user', pass: 'new_uuid'}]"
        operation: "regenerate config from users.json"
        generator: "lib/orchestrator.sh::generate_xray_config()"

      - file: "/opt/familytraffic/data/clients/<username>/"
        before: "Directory does not exist"
        after: "Directory created with 6 files"
        files_created:
          - "vless_config.json (VLESS client config)"
          - "vless_link.txt (vless:// deep link)"
          - "vless_qr.png (QR code for vless://)"
          - "socks5_config.txt (SOCKS5 credentials)"
          - "http_config.txt (HTTP proxy credentials)"
          - "qr_codes.html (HTML with all QR codes)"
        operation: "generate_client_configs()"

    side_effects:
      - action: "reload_xray()"
        method: "docker exec familytraffic kill -HUP <pid>"
        downtime: "~0s (graceful reload)"
        purpose: "Apply new user to Xray inbounds"

      - action: "display_client_configs()"
        output:
          - "QR codes (displayed in terminal)"
          - "Connection URIs (vless://, socks5s://, etc.)"
          - "File paths to client configs"

    duration: "~3-5 seconds"
    diagram_reference: "diagrams/sequences/user-management.md"

  user_management_remove_user:
    name: "Remove User State Transition Flow"
    trigger: "sudo familytraffic remove-user <username>"
    purpose: "Delete VPN user and revoke access"

    state_changes:
      - file: "/opt/familytraffic/data/users.json"
        before:
          users: "['user1', 'user_to_delete', 'user2']"
        after:
          users: "['user1', 'user2']"
        operation: "remove user object by username"
        locking: "flock /var/lock/familytraffic_users.lock"
        atomic_write: true

      - file: "/opt/familytraffic/config/xray_config.json"
        before:
          inbounds_clients: "[..., {id: 'deleted_uuid', email: 'deleted@vless.local'}, ...]"
        after:
          inbounds_clients: "[clients without deleted user]"
        operation: "regenerate config from users.json"

      - file: "/opt/familytraffic/data/clients/<username>/"
        before: "Directory exists with client configs"
        after: "Directory deleted"
        operation: "rm -rf /opt/familytraffic/data/clients/<username>"

    side_effects:
      - action: "reload_xray()"
        method: "SIGHUP"
        downtime: "~0s"
        purpose: "Remove user from active clients (immediate revocation)"

    duration: "~2-3 seconds"
    diagram_reference: "diagrams/sequences/user-management.md"

  proxy_assignment_set_proxy:
    name: "Set User External Proxy State Transition"
    trigger: "sudo familytraffic set-proxy <username> <proxy-id>"
    feature_version: "v5.24+"
    purpose: "Assign upstream proxy to specific user"

    state_changes:
      - file: "/opt/familytraffic/data/users.json"
        before:
          user_object: "{username: 'alice', external_proxy_id: null, ...}"
        after:
          user_object: "{username: 'alice', external_proxy_id: 'proxy-1', ...}"
        operation: "update user object"
        locking: "flock /var/lock/familytraffic_users.lock"

      - file: "/opt/familytraffic/config/xray_config.json"
        before:
          routing_rules: "[{type: 'field', user: [], outboundTag: 'external-proxy'}, ...]"
        after:
          routing_rules: "[{type: 'field', user: ['alice@vless.local'], outboundTag: 'external-proxy'}, ...]"
        operation: "regenerate routing rules from users.json"
        generator: "lib/xray_routing_manager.sh::update_xray_routing_for_user()"

    validation:
      - "User exists in users.json"
      - "Proxy ID exists in external_proxy.json"
      - "Proxy is enabled (proxies[].enabled == true)"
      - "xray_config.json validates successfully"

    side_effects:
      - action: "reload_xray()"
        method: "SIGHUP"
        downtime: "~0s"
        purpose: "Apply new routing rule (user traffic now via proxy)"

    duration: "~2-4 seconds"
    diagram_reference: "diagrams/sequences/proxy-assignment.md"

  certificate_renewal_flow:
    name: "Automated Certificate Renewal Flow"
    trigger: "certbot renew (cron job every 12 hours)"
    purpose: "Renew Let's Encrypt certificates before expiration"

    steps:
      - stage: "Certbot Renewal Check"
        component: "certbot (cron job)"
        action: "Check if certificates are due for renewal (< 30 days to expiry)"

        certificates_checked:
          - "/etc/letsencrypt/live/${DOMAIN}/ (main VPN domain)"
          - "/etc/letsencrypt/live/<subdomain1>/ (reverse proxy domains)"
          - "/etc/letsencrypt/live/<subdomainN>/"

      - stage: "ACME HTTP-01 Challenge"
        component: "certbot + familytraffic-certbot"
        action: "Perform HTTP-01 challenge for each certificate"

        challenge_flow:
          - "Certbot generates challenge file"
          - "Certbot places file in /var/www/certbot/.well-known/acme-challenge/"
          - "Certbot starts familytraffic-certbot container (port 80)"
          - "Let's Encrypt fetches http://domain/.well-known/acme-challenge/<token>"
          - "familytraffic-certbot serves challenge file"
          - "Let's Encrypt validates ownership"

      - stage: "Certificate Issuance"
        component: "Let's Encrypt CA"
        action: "Issue new certificate (90-day validity)"

        files_updated:
          - "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem"
          - "/etc/letsencrypt/live/${DOMAIN}/privkey.pem"
          - "/etc/letsencrypt/archive/${DOMAIN}/ (archived versions)"

      - stage: "Certificate Combination"
        component: "certbot renewal hook"
        action: "Combine fullchain + privkey for HAProxy"

        operation: "cat fullchain.pem privkey.pem > combined.pem"
        output: "/etc/letsencrypt/live/${DOMAIN}/combined.pem"
        purpose: "HAProxy requires single file with cert + key"

      - stage: "Service Reloads"
        component: "certbot post-renewal hooks"
        action: "Reload HAProxy and Nginx to use new certificates"

        reloads:
          haproxy:
            command: "docker exec familytraffic-haproxy haproxy -sf <old_pid>"
            downtime: "~0s (graceful reload)"
            purpose: "Apply new certificate for SOCKS5/HTTP TLS termination"

          nginx:
            command: "docker exec familytraffic-nginx nginx -s reload"
            downtime: "~0s (graceful reload)"
            purpose: "Apply new certificates for reverse proxy domains"

    state_changes:
      - file: "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem"
        before: "Old certificate (expires in < 30 days)"
        after: "New certificate (expires in 90 days)"

      - file: "/etc/letsencrypt/live/${DOMAIN}/combined.pem"
        before: "Old combined cert"
        after: "New combined cert (fullchain + privkey)"

    frequency: "Every 12 hours (cron: 0 */12 * * *)"
    renewal_threshold: "30 days before expiration"
    duration: "~30-60 seconds per domain"
    downtime: "~0s (graceful reloads)"

    diagram_reference: "diagrams/sequences/cert-renewal.md"

  config_propagation_flow:
    name: "Configuration Update Propagation Flow"
    trigger: "User management commands (add-user, set-proxy, etc.)"
    purpose: "Propagate changes from users.json to all dependent configs"

    propagation_chain:
      - step: 1
        action: "Update source of truth"
        file: "/opt/familytraffic/data/users.json"
        operation: "Atomic write with flock"
        duration: "< 100ms"

      - step: 2
        action: "Regenerate Xray config"
        trigger: "users.json modified"
        generator: "lib/orchestrator.sh::generate_xray_config()"
        inputs:
          - "/opt/familytraffic/data/users.json"
          - "/opt/familytraffic/config/external_proxy.json (if exists)"
        output: "/opt/familytraffic/config/xray_config.json"
        validation: "xray test -c config.json"
        duration: "~500ms"

      - step: 3
        action: "Reload Xray service"
        method: "SIGHUP signal"
        command: "docker exec familytraffic kill -HUP <pid>"
        effect: "Xray reloads config without dropping connections"
        downtime: "~0s"
        duration: "~1s"

      - step: 4
        action: "Generate client configs (if add-user)"
        condition: "add-user command only"
        generator: "lib/qr_generator.sh::generate_client_configs()"
        outputs:
          - "/opt/familytraffic/data/clients/<username>/vless_config.json"
          - "/opt/familytraffic/data/clients/<username>/vless_qr.png"
          - "/opt/familytraffic/data/clients/<username>/socks5_config.txt"
        duration: "~2s"

    total_duration: "~3-5 seconds (with client config generation)"
    total_downtime: "~0s (graceful reloads)"

    diagram_reference: "diagrams/sequences/config-update.md"

mtproxy_data_flow:
  name: "MTProxy Telegram Traffic Flow (v6.0+, PLANNED)"
  protocol: "MTProto with transport obfuscation"
  entry_point: "Client connects to server:8443"
  purpose: "Telegram-specific proxy with DPI resistance"
  feature_version: "v6.0+ (planned implementation)"
  implementation_status: "PLANNED (not yet implemented)"

  steps:
    - stage: "Client Connection"
      component: "Telegram Client (Mobile/Desktop)"
      action: "Connects to MTProxy server"
      connection_methods:
        deep_link: "tg://proxy?server=<ip>&port=8443&secret=<secret>"
        manual_config: "Settings → Data and Storage → Proxy → MTProxy"
        qr_code: "Scan QR code with MTProxy config"

      data_transmitted:
        - "MTProto handshake (obfuscated)"
        - "Client secret (40 hex chars)"

    - stage: "MTProxy Authentication"
      component: "familytraffic-mtproxy"
      port: 8443
      binding: "0.0.0.0:8443 (public, NO conflict with Xray 127.0.0.1:8443)"
      action: "Validate client secret and establish connection"

      authentication:
        method: "Secret-based (no username/password)"
        secrets_source: "/opt/familytraffic/config/mtproxy/proxy-secret"
        validation:
          v6_0: "Single secret (all users share)"
          v6_1: "Per-user unique secrets (users[].mtproxy_secret)"

      on_success:
        action: "Proceed to Telegram DC connection"

      on_failure:
        action: "Close connection"
        response: "Invalid secret"

    - stage: "Transport Obfuscation"
      component: "familytraffic-mtproxy"
      action: "Apply MTProto transport obfuscation"

      obfuscation:
        method: "AES-256-CTR encryption"
        padding: "Random padding to mask packet sizes"
        purpose: "Evade DPI detection"

      fake_tls_mode:
        feature_version: "v6.1+"
        enabled_if: "Secret starts with 'ee' prefix"
        action: "Additional TLS-like packet structure"
        purpose: "Appear as HTTPS traffic to DPI systems"

    - stage: "Telegram DC Connection"
      component: "familytraffic-mtproxy → Telegram Data Centers"
      action: "Proxy traffic to Telegram servers"

      dc_addresses:
        source: "/opt/familytraffic/config/mtproxy/proxy-multi.conf"
        purpose: "List of Telegram DC IP addresses"
        update_frequency: "Rarely (only when Telegram adds DCs)"

      connection:
        protocol: "MTProto"
        encryption: "Client-to-Telegram end-to-end"
        proxy_role: "Transparent tunnel (MTProxy doesn't decrypt)"

    - stage: "Telegram Service"
      component: "Telegram Data Centers"
      action: "Process Telegram client requests"

      visible_source:
        ip: "MTProxy server IP (VPN server)"
        note: "Telegram sees MTProxy IP, not client IP"

    - stage: "Return Path"
      component: "Telegram DC → MTProxy → Client"
      action: "Response data follows reverse path"

      flow:
        - "Telegram DC → MTProxy (MTProto)"
        - "MTProxy applies obfuscation"
        - "MTProxy → Client:8443 (obfuscated MTProto)"

  configuration_management:
    add_secret_v6_0:
      command: "sudo mtproxy add-secret [--with-padding]"
      affected_files:
        - "/opt/familytraffic/config/mtproxy/proxy-secret (append secret)"
      service_restart: "docker restart familytraffic-mtproxy (~2-5s downtime)"

    add_user_v6_1:
      command: "sudo mtproxy add-user <username> [--fake-tls <domain>]"
      affected_files:
        - "/opt/familytraffic/data/users.json (add mtproxy_secret field)"
        - "/opt/familytraffic/config/mtproxy/proxy-secret (append user secret)"
        - "/opt/familytraffic/data/clients/<username>/mtproxy_config.txt (generate config)"
      service_restart: "docker restart familytraffic-mtproxy (~2-5s downtime)"

  performance:
    latency_overhead: "< 5ms (obfuscation)"
    throughput: "Limited by VPN server bandwidth"
    concurrent_connections: "100+ users (recommended max 50 for v6.1)"

  security:
    transport_obfuscation: "AES-256-CTR + random padding"
    dpi_resistance: "HIGH (MTProto designed for censorship evasion)"
    fake_tls: "v6.1+ feature (additional stealth layer)"
    end_to_end_encryption: "Client to Telegram (MTProxy doesn't decrypt)"

  limitations:
    - "No HAProxy integration (MTProto doesn't use SNI)"
    - "Port 8443 must be public (different binding from Xray)"
    - "Secret rotation requires container restart (~2-5s downtime)"
    - "Per-secret statistics not available (only server-level stats)"

  diagram_reference: "diagrams/data-flows/mtproxy-flow.md (planned)"

performance_characteristics:
  latency_breakdown:
    vless_reality:
      haproxy_sni_routing: "< 1ms"
      xray_reality_handshake: "3-5ms"
      xray_routing_decision: "< 1ms"
      external_proxy_connection: "0ms (direct) or 50-200ms (with proxy)"
      total: "< 10ms (direct) or 50-210ms (with external proxy)"

    socks5_tls:
      haproxy_tls_termination: "2-3ms"
      xray_socks5_auth: "< 1ms"
      xray_routing: "< 1ms"
      total: "< 5ms (direct)"

    http_tls:
      haproxy_tls_termination: "2-3ms"
      xray_http_auth: "< 1ms"
      xray_connect_tunnel: "< 1ms"
      total: "< 5ms (direct)"

    reverse_proxy:
      haproxy_sni_routing: "< 1ms"
      nginx_tls_termination: "2-3ms"
      nginx_proxy_pass: "5-10ms"
      total: "< 15ms"

  throughput_limits:
    bottlenecks:
      - "VPN server network bandwidth (primary limit)"
      - "HAProxy TLS encryption/decryption (CPU-bound)"
      - "External proxy bandwidth (if used)"
      - "Nginx rate limiting (reverse proxy)"

    optimization:
      - "HAProxy uses hardware TLS acceleration"
      - "Xray graceful reloads preserve connections"
      - "Nginx rate limiting prevents abuse"

references:
  diagrams:
    - "diagrams/data-flows/vless-reality-flow.md - VLESS Reality flow diagram"
    - "diagrams/data-flows/socks5-proxy-flow.md - SOCKS5 TLS flow diagram"
    - "diagrams/data-flows/http-proxy-flow.md - HTTP proxy flow diagram"
    - "diagrams/data-flows/reverse-proxy-flow.md - Reverse proxy flow diagram"
    - "diagrams/data-flows/external-proxy-flow.md - External proxy chaining diagram"

  documentation:
    - "docs/prd/04_architecture.md - Architecture details"
    - "docs/prd/02_functional_requirements.md - Functional requirements"
    - "CLAUDE.md - Project memory and quick reference"

  implementation:
    - "lib/orchestrator.sh::generate_xray_config() - Xray config generation"
    - "lib/haproxy_config_manager.sh::generate_haproxy_config() - HAProxy config"
    - "lib/xray_routing_manager.sh::update_xray_routing_for_user() - Per-user routing"
    - "lib/reverseproxy_db.sh::add_reverse_proxy_domain() - Reverse proxy setup"

notes:
  - "All flows support graceful configuration reloads (zero downtime)"
  - "External proxy support is per-user (v5.24+ feature)"
  - "Reverse proxy limited to 10 concurrent domains (port slots)"
  - "MTProxy flow is planned (v6.0+), not yet implemented"
  - "Certificate renewal fully automated (certbot cron + hooks)"
  - "All state changes use atomic writes and file locking"
