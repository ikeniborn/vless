version: "1.0"
documentation_version: "v5.26"
last_updated: "2026-01-07"

project:
  name: "VLESS + Reality VPN - Configuration Architecture"
  version: "v5.26"
  description: "Comprehensive documentation of all configuration files, their structure, relationships, and propagation paths"

configurations:
  xray_config:
    path: "/opt/vless/config/xray_config.json"
    format: "JSON"
    purpose: "Xray-core runtime configuration - defines inbounds, outbounds, and routing rules"
    critical: true
    reload_method: "SIGHUP signal (graceful, zero downtime)"
    reload_command: "docker exec vless_xray kill -HUP $(docker exec vless_xray pgrep xray)"
    generator_module: "lib/orchestrator.sh"
    generator_function: "generate_xray_config()"
    validation_method: "xray test -c /opt/vless/config/xray_config.json"

    sections:
      log:
        access: "/var/log/xray/access.log"
        error: "/var/log/xray/error.log"
        loglevel: "warning"

      inbounds:
        - name: "vless-in"
          protocol: "vless"
          port: 8443
          listen: "127.0.0.1"
          purpose: "VLESS Reality protocol handler"

          settings:
            clients:
              source: "/opt/vless/data/users.json"
              mapping: "users[] → clients[]"
              transformation:
                - "users[].uuid → clients[].id"
                - "users[].email → clients[].email"
                - "users[].flow → clients[].flow"
              example:
                id: "UUID-from-users-json"
                email: "user@vless.local"
                flow: "xtls-rprx-vision"

            decryption: "none"

            fallbacks:
              - dest: "vless_fake_site:80"
                xver: 0
                description: "Fallback for invalid UUID or Reality handshake failure"

          streamSettings:
            network: "tcp"
            security: "reality"
            realitySettings:
              show: false
              dest: "www.microsoft.com:443"
              serverNames:
                - "www.microsoft.com"
              privateKey: "${REALITY_PRIVATE_KEY}"
              shortIds:
                - ""
                - "0123456789abcdef"
              note: "Reality protocol masks VPN traffic as legitimate TLS to www.microsoft.com"

          sniffing:
            enabled: true
            destOverride:
              - "http"
              - "tls"
            metadataOnly: false

        - name: "socks-in"
          protocol: "socks"
          port: 10800
          listen: "127.0.0.1"
          purpose: "Plaintext SOCKS5 inbound (after HAProxy TLS termination)"

          settings:
            auth: "password"
            accounts:
              source: "/opt/vless/data/users.json"
              mapping: "users[] → accounts[]"
              transformation:
                - "users[].username → accounts[].user"
                - "users[].uuid → accounts[].pass"
              example:
                user: "alice"
                pass: "UUID-from-users-json"
            udp: true
            ip: "127.0.0.1"

          sniffing:
            enabled: true
            destOverride:
              - "http"
              - "tls"
            metadataOnly: false

        - name: "http-in"
          protocol: "http"
          port: 18118
          listen: "127.0.0.1"
          purpose: "Plaintext HTTP proxy inbound (after HAProxy TLS termination)"

          settings:
            auth: "password"
            accounts:
              source: "/opt/vless/data/users.json"
              mapping: "users[] → accounts[]"
              transformation:
                - "users[].username → accounts[].user"
                - "users[].uuid → accounts[].pass"
              example:
                user: "alice"
                pass: "UUID-from-users-json"

          sniffing:
            enabled: true
            destOverride:
              - "http"
              - "tls"
            metadataOnly: false

      outbounds:
        - tag: "direct"
          protocol: "freedom"
          purpose: "Direct internet access (default for all users without external proxy)"
          settings:
            domainStrategy: "UseIP"
            redirect: null

        - tag: "external-proxy"
          protocol: "socks"
          purpose: "External upstream proxy routing (v5.24+ per-user feature)"
          feature_version: "v5.24+"
          settings:
            servers:
              source: "/opt/vless/config/external_proxy.json"
              mapping: "proxies[] → servers[]"
              dynamic: true
              transformation:
                - "proxies[].address → servers[].address"
                - "proxies[].port → servers[].port"
                - "proxies[].protocol → protocol (socks/http)"
                - "proxies[].username → servers[].users[].user"
                - "proxies[].password → servers[].users[].pass"
              conditional: "Only active if external_proxy.json exists and has enabled proxies"

        - tag: "block"
          protocol: "blackhole"
          purpose: "Block specific traffic (optional, for future use)"
          settings:
            response:
              type: "http"

      routing:
        domainStrategy: "IPIfNonMatch"

        rules:
          - description: "Per-user external proxy routing (v5.24+)"
            type: "field"
            feature_version: "v5.24+"
            condition: "User has external_proxy_id set in users.json"

            inboundTag:
              - "vless-in"
              - "socks-in"
              - "http-in"

            user:
              source: "/opt/vless/data/users.json"
              field: "users[].email (for VLESS) or users[].username (for SOCKS5/HTTP)"
              transformation: "users[].external_proxy_id != null → add to rule.user[]"
              generator: "lib/xray_routing_manager.sh::update_xray_routing_for_user()"
              example:
                - "user@vless.local"
                - "alice@vless.local"

            outboundTag: "external-proxy"

            note: "This rule is dynamically generated based on users.json external_proxy_id assignments"

          - description: "Default routing to direct internet"
            type: "field"
            outboundTag: "direct"

    data_sources:
      - file: "/opt/vless/data/users.json"
        fields_used:
          - "users[].uuid → inbounds clients[].id, accounts[].pass"
          - "users[].email → inbounds clients[].email"
          - "users[].username → inbounds accounts[].user"
          - "users[].flow → inbounds clients[].flow"
          - "users[].external_proxy_id → routing.rules[].user[]"
        trigger: "add-user, remove-user, set-proxy commands"

      - file: "/opt/vless/config/external_proxy.json"
        fields_used:
          - "proxies[].address → outbounds servers[].address"
          - "proxies[].port → outbounds servers[].port"
          - "proxies[].protocol → outbounds protocol"
          - "proxies[].username → outbounds servers[].users[].user"
          - "proxies[].password → outbounds servers[].users[].pass"
        trigger: "vless-external-proxy add, enable, disable commands"

    generation_flow:
      entry_point: "lib/orchestrator.sh::generate_xray_config()"
      steps:
        - "Read /opt/vless/data/users.json"
        - "Read /opt/vless/config/external_proxy.json (if exists)"
        - "Generate inbounds.clients[] from users[].uuid"
        - "Generate inbounds.accounts[] from users[].username + uuid"
        - "Generate routing.rules[] for users with external_proxy_id"
        - "Generate outbounds.servers[] from proxies[]"
        - "Validate JSON syntax"
        - "Write to /opt/vless/config/xray_config.json (atomic)"
        - "Reload Xray (SIGHUP)"

  haproxy_config:
    path: "/opt/vless/config/haproxy.cfg"
    format: "HAProxy configuration format"
    purpose: "HAProxy unified TLS termination & SNI-based routing"
    critical: true
    reload_method: "Graceful reload (seamless, zero downtime)"
    reload_command: "docker exec vless_haproxy haproxy -sf $(docker exec vless_haproxy cat /var/run/haproxy.pid)"
    generator_module: "lib/haproxy_config_manager.sh"
    generator_function: "generate_haproxy_config()"
    validation_method: "haproxy -c -f /opt/vless/config/haproxy.cfg"

    sections:
      global:
        log: "/dev/log local0"
        log_level: "info"
        chroot: "/var/lib/haproxy"
        stats_socket: "/run/haproxy/admin.sock mode 660 level admin"
        stats_timeout: "30s"
        user: "haproxy"
        group: "haproxy"
        daemon: true
        maxconn: 20000
        tune_ssl_default_dh_param: 2048

      defaults:
        log: "global"
        mode: "tcp"
        option:
          - "dontlognull"
          - "tcp-smart-accept"
          - "tcp-smart-connect"
        timeout_connect: "5s"
        timeout_client: "50s"
        timeout_server: "50s"

      frontends:
        https_sni_router:
          bind: "*:443"
          mode: "tcp"
          purpose: "SNI-based routing without TLS decryption"

          tcp_request_content:
            - "accept if { req_ssl_hello_type 1 }"

          acls:
            static:
              - name: "is_vless"
                condition: "req_ssl_sni -i ${VLESS_DOMAIN}"
                backend: "xray_vless"
                action: "Passthrough to Xray:8443"

            dynamic:
              marker: "# DYNAMIC_REVERSE_PROXY_ROUTES"
              purpose: "Runtime-added reverse proxy subdomains"
              generator: "lib/haproxy_config_manager.sh::add_haproxy_acl_for_domain()"
              format: |
                acl is_<sanitized_domain> req.ssl_sni -i <subdomain.example.com>
                use_backend nginx_<sanitized_domain> if is_<sanitized_domain>
              example:
                - acl: "is_claude_example_com req.ssl_sni -i claude.example.com"
                  use_backend: "use_backend nginx_claude_example_com if is_claude_example_com"

            fallback:
              condition: "default_backend fake_site_fallback"
              purpose: "Unknown SNI → Fake nginx site"

        socks5_tls_frontend:
          bind: "*:1080 ssl crt /etc/letsencrypt/live/${DOMAIN}/combined.pem alpn h2,http/1.1"
          mode: "tcp"
          purpose: "SOCKS5 over TLS - TLS termination"
          default_backend: "xray_socks5_plaintext"

          tls_action: "Decrypt TLS with Let's Encrypt certificate"
          certificate: "/etc/letsencrypt/live/${DOMAIN}/combined.pem"

        http_tls_frontend:
          bind: "*:8118 ssl crt /etc/letsencrypt/live/${DOMAIN}/combined.pem alpn h2,http/1.1"
          mode: "tcp"
          purpose: "HTTP proxy over TLS - TLS termination"
          default_backend: "xray_http_plaintext"

          tls_action: "Decrypt TLS with Let's Encrypt certificate"
          certificate: "/etc/letsencrypt/live/${DOMAIN}/combined.pem"

        stats_frontend:
          bind: "127.0.0.1:9000"
          mode: "http"
          purpose: "HAProxy statistics and monitoring"
          stats:
            enable: true
            uri: "/stats"
            refresh: "30s"
            realm: "HAProxy Statistics"

      backends:
        xray_vless:
          mode: "tcp"
          balance: "roundrobin"
          server: "xray 127.0.0.1:8443 check inter 10s fall 3 rise 2"
          purpose: "VLESS Reality backend (TLS passthrough)"

        xray_socks5_plaintext:
          mode: "tcp"
          balance: "roundrobin"
          server: "xray 127.0.0.1:10800 check inter 10s fall 3 rise 2"
          purpose: "Plaintext SOCKS5 backend (after TLS termination)"

        xray_http_plaintext:
          mode: "tcp"
          balance: "roundrobin"
          server: "xray 127.0.0.1:18118 check inter 10s fall 3 rise 2"
          purpose: "Plaintext HTTP proxy backend (after TLS termination)"

        nginx_reverse_proxy_backends:
          pattern: "nginx_<sanitized_domain>"
          mode: "tcp"
          balance: "roundrobin"
          server_pattern: "nginx 127.0.0.1:<9443-9452> check inter 10s fall 3 rise 2 ssl verify none"
          purpose: "Reverse proxy backends (one per subdomain, dynamically added)"
          example:
            name: "nginx_claude_example_com"
            server: "nginx 127.0.0.1:9443 check inter 10s fall 3 rise 2 ssl verify none"
          generator: "lib/haproxy_config_manager.sh::add_haproxy_acl_for_domain()"

        fake_site_fallback:
          mode: "tcp"
          balance: "roundrobin"
          server: "fake_site vless_fake_site:80 check inter 10s fall 3 rise 2"
          purpose: "Fallback for unknown SNI"

    dynamic_sections:
      reverse_proxy_routes:
        location: "Between static ACLs and fallback backend"
        marker_start: "# DYNAMIC_REVERSE_PROXY_ROUTES"
        marker_end: "# END DYNAMIC_REVERSE_PROXY_ROUTES"
        format: |
          # DYNAMIC_REVERSE_PROXY_ROUTES
          acl is_claude_example_com req.ssl_sni -i claude.example.com
          use_backend nginx_claude_example_com if is_claude_example_com
          # ... more dynamic routes ...
          # END DYNAMIC_REVERSE_PROXY_ROUTES

        management:
          add_route: "lib/haproxy_config_manager.sh::add_haproxy_acl_for_domain()"
          remove_route: "lib/haproxy_config_manager.sh::remove_haproxy_acl_for_domain()"
          list_routes: "lib/haproxy_config_manager.sh::list_reverse_proxy_domains()"

    data_sources:
      - file: "/opt/vless/config/reverse-proxy/domains.list"
        purpose: "List of configured reverse proxy domains"
        format: "One domain per line"
        trigger: "vless-proxy add, vless-proxy remove commands"

    generation_flow:
      entry_point: "lib/haproxy_config_manager.sh::generate_haproxy_config()"
      steps:
        - "Generate static frontends and backends"
        - "Read /opt/vless/config/reverse-proxy/ directory"
        - "For each *.conf file, extract domain name"
        - "Generate dynamic ACL + use_backend for each domain"
        - "Insert dynamic section between markers"
        - "Validate HAProxy syntax"
        - "Write to /opt/vless/config/haproxy.cfg (atomic)"
        - "Graceful reload HAProxy"

  users_json:
    path: "/opt/vless/data/users.json"
    format: "JSON"
    purpose: "User database - single source of truth for all user information"
    critical: true
    backup_required: true
    concurrency_control: "flock /var/lock/vless_users.lock"

    schema:
      root:
        type: "object"
        properties:
          users:
            type: "array"
            description: "Array of user objects"

      user_object:
        type: "object"
        required_fields:
          - field: "username"
            type: "string"
            format: "^[a-z][a-z0-9_-]{2,31}$"
            description: "Unique username (3-32 chars, lowercase, alphanumeric + underscore/hyphen)"
            unique: true

          - field: "uuid"
            type: "string"
            format: "UUIDv4"
            description: "Unique user UUID (used as VLESS client ID and SOCKS5/HTTP password)"
            unique: true
            generator: "uuidgen"

          - field: "email"
            type: "string"
            format: "username@vless.local"
            description: "Email identifier for Xray (username + @vless.local)"
            unique: true

          - field: "flow"
            type: "string"
            enum: ["xtls-rprx-vision"]
            description: "VLESS flow control (xtls-rprx-vision for Reality)"
            default: "xtls-rprx-vision"

          - field: "created_at"
            type: "string"
            format: "ISO 8601 timestamp"
            description: "User creation timestamp"
            example: "2025-11-23T15:30:45Z"

        optional_fields:
          - field: "external_proxy_id"
            type: "string or null"
            description: "Reference to external proxy in external_proxy.json (v5.24+)"
            feature_version: "v5.24+"
            default: null
            example: "proxy-1"
            purpose: "Per-user external proxy routing"

          - field: "mtproxy_secret"
            type: "string or null"
            format: "40 hex chars (ee prefix for fake-TLS)"
            description: "Per-user MTProxy secret (v6.1+)"
            feature_version: "v6.1+ (future enhancement)"
            default: null
            example: "ee1234567890abcdef1234567890abcdef1234567890ab"
            purpose: "Multi-user MTProxy support"

    example_record:
      username: "alice"
      uuid: "a1b2c3d4-e5f6-7890-1234-567890abcdef"
      email: "alice@vless.local"
      flow: "xtls-rprx-vision"
      created_at: "2025-11-23T15:30:45Z"
      external_proxy_id: null
      mtproxy_secret: null

    operations:
      add_user:
        function: "lib/user_management.sh::add_user_to_json()"
        locking: "flock /var/lock/vless_users.lock"
        atomic_write: true
        validation:
          - "Username uniqueness"
          - "UUID format validation"
          - "Email format validation"
        side_effects:
          - "Regenerate xray_config.json"
          - "Reload Xray (SIGHUP)"
          - "Generate client configs"

      remove_user:
        function: "lib/user_management.sh::remove_user_from_json()"
        locking: "flock /var/lock/vless_users.lock"
        atomic_write: true
        side_effects:
          - "Regenerate xray_config.json"
          - "Reload Xray (SIGHUP)"
          - "Delete client configs"

      set_user_proxy:
        function: "lib/user_management.sh::update_user_proxy_id()"
        locking: "flock /var/lock/vless_users.lock"
        atomic_write: true
        feature_version: "v5.24+"
        validation:
          - "User exists"
          - "Proxy ID exists in external_proxy.json"
        side_effects:
          - "Update routing rules in xray_config.json"
          - "Reload Xray (SIGHUP)"

    consumer_configs:
      - config: "xray_config.json"
        fields: "uuid, email, flow, external_proxy_id"
        generator: "lib/orchestrator.sh::generate_xray_config()"

      - config: "mtproxy/proxy-secret"
        fields: "mtproxy_secret"
        generator: "lib/mtproxy_secret_manager.sh::generate_proxy_secret_file()"
        feature_version: "v6.1+"

      - config: "clients/<username>/"
        fields: "uuid, username, email"
        generator: "lib/qr_generator.sh::generate_client_configs()"

  external_proxy_json:
    path: "/opt/vless/config/external_proxy.json"
    format: "JSON"
    purpose: "External upstream proxy configuration (v5.24+)"
    critical: false
    feature_version: "v5.24+"
    optional: true

    schema:
      root:
        type: "object"
        properties:
          proxies:
            type: "array"
            description: "Array of external proxy objects"
            max_items: 10
            note: "Recommend max 5 proxies for manageability"

      proxy_object:
        type: "object"
        required_fields:
          - field: "id"
            type: "string"
            format: "^proxy-[0-9]+$"
            description: "Unique proxy identifier"
            unique: true
            example: "proxy-1"

          - field: "name"
            type: "string"
            description: "Human-readable proxy name"
            example: "US Proxy 1"

          - field: "protocol"
            type: "string"
            enum: ["socks5", "socks5s", "http", "https"]
            description: "Proxy protocol (socks5/socks5s recommended)"
            note: "socks5s = SOCKS5 over TLS"

          - field: "address"
            type: "string"
            description: "Proxy server address (IP or domain)"
            example: "proxy.example.com"

          - field: "port"
            type: "integer"
            range: "1-65535"
            description: "Proxy server port"
            example: 1080

          - field: "username"
            type: "string"
            description: "Proxy authentication username"

          - field: "password"
            type: "string"
            description: "Proxy authentication password"
            sensitive: true

          - field: "enabled"
            type: "boolean"
            description: "Whether this proxy is currently active"
            default: true

          - field: "created_at"
            type: "string"
            format: "ISO 8601 timestamp"
            description: "Proxy creation timestamp"

    example_record:
      id: "proxy-1"
      name: "US Proxy 1"
      protocol: "socks5s"
      address: "proxy.example.com"
      port: 1080
      username: "user123"
      password: "pass456"
      enabled: true
      created_at: "2025-10-25T10:15:30Z"

    operations:
      add_proxy:
        function: "lib/external_proxy_manager.sh::add_external_proxy()"
        validation:
          - "Proxy connectivity test (curl via proxy)"
          - "Protocol validation"
          - "Address reachability"
        side_effects:
          - "Regenerate xray_config.json"
          - "Restart Xray container"

      remove_proxy:
        function: "lib/external_proxy_manager.sh::remove_external_proxy()"
        validation:
          - "No users assigned to this proxy"
        side_effects:
          - "Regenerate xray_config.json"
          - "Restart Xray container"

      enable_disable_proxy:
        function: "lib/external_proxy_manager.sh::toggle_external_proxy()"
        side_effects:
          - "Regenerate xray_config.json"
          - "Restart Xray container"

    consumer_configs:
      - config: "xray_config.json"
        fields: "address, port, protocol, username, password, enabled"
        generator: "lib/orchestrator.sh::generate_xray_config()"

  nginx_reverse_proxy_configs:
    path_pattern: "/opt/vless/config/reverse-proxy/<domain>.conf"
    format: "Nginx configuration format"
    purpose: "Per-domain reverse proxy configuration"
    critical: true
    reload_method: "SIGHUP signal"
    reload_command: "docker exec vless_nginx_reverseproxy nginx -s reload"
    generator_module: "lib/reverseproxy_db.sh"
    generator_function: "add_reverse_proxy_domain()"

    per_domain_structure:
      server_block:
        listen: "9443-9452 ssl http2"
        server_name: "<subdomain.example.com>"

        ssl_certificate: "/etc/letsencrypt/live/<subdomain.example.com>/fullchain.pem"
        ssl_certificate_key: "/etc/letsencrypt/live/<subdomain.example.com>/privkey.pem"
        ssl_protocols: "TLSv1.2 TLSv1.3"
        ssl_ciphers: "HIGH:!aNULL:!MD5"
        ssl_prefer_server_ciphers: "on"

        rate_limiting:
          limit_req_zone: "reverseproxy_<sanitized_domain>:10m"
          limit_req: "zone=reverseproxy_<sanitized_domain> burst=20 nodelay"
          note: "Zone MUST be defined in http_context.conf"

        location_root:
          path: "/"
          proxy_pass: "<target_url>"
          proxy_headers:
            - "Host: <target_host>"
            - "X-Real-IP: $remote_addr"
            - "X-Forwarded-For: $proxy_add_x_forwarded_for"
            - "X-Forwarded-Proto: https"
            - "Upgrade: $http_upgrade (for WebSocket)"
            - "Connection: $connection_upgrade (for WebSocket)"
          proxy_timeouts:
            - "proxy_connect_timeout: 60s"
            - "proxy_send_timeout: 60s"
            - "proxy_read_timeout: 60s"

        advanced_features:
          oauth2:
            enabled: false
            description: "Optional OAuth2 authentication"
            implementation: "auth_request directive"

          websocket:
            enabled: "auto-detect via Upgrade header"
            description: "WebSocket support"

          csp:
            enabled: false
            description: "Content-Security-Policy headers"
            example: "default-src 'self'; script-src 'self' 'unsafe-inline'"

          custom_errors:
            enabled: true
            error_pages:
              - "error_page 502 503 504 /50x.html"

    example_config:
      domain: "claude.example.com"
      target: "https://claude.ai"
      port: 9443
      rate_limit: "100r/s"
      content: |
        server {
            listen 9443 ssl http2;
            server_name claude.example.com;

            ssl_certificate /etc/letsencrypt/live/claude.example.com/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/claude.example.com/privkey.pem;

            limit_req zone=reverseproxy_claude_example_com burst=20 nodelay;

            location / {
                proxy_pass https://claude.ai;
                proxy_set_header Host claude.ai;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto https;
            }
        }

    operations:
      add_domain:
        function: "lib/reverseproxy_db.sh::add_reverse_proxy_domain()"
        steps:
          - "Allocate available port (9443-9452)"
          - "Generate Nginx config"
          - "Add rate limit zone to http_context.conf"
          - "Reload Nginx"
          - "Generate HAProxy ACL"
          - "Reload HAProxy"
        validation:
          - "Domain DNS validation"
          - "Target URL reachability"
          - "Port availability"

      remove_domain:
        function: "lib/reverseproxy_db.sh::remove_reverse_proxy_domain()"
        steps:
          - "Delete Nginx config"
          - "Remove rate limit zone from http_context.conf"
          - "Reload Nginx"
          - "Remove HAProxy ACL"
          - "Reload HAProxy"

  http_context_conf:
    path: "/opt/vless/config/reverse-proxy/http_context.conf"
    format: "Nginx HTTP context includes"
    purpose: "Shared rate limit zone definitions for all reverse proxy domains"
    critical: true
    note: "Rate limit zones MUST be defined in HTTP context, not server blocks"

    structure:
      include_directive: "include /etc/nginx/http_context.conf;"
      location: "nginx.conf http { } block"

      rate_limit_zones:
        format: "limit_req_zone $binary_remote_addr zone=<zone_name>:10m rate=<rate>r/s;"
        example: |
          limit_req_zone $binary_remote_addr zone=reverseproxy_claude_example_com:10m rate=100r/s;
          limit_req_zone $binary_remote_addr zone=reverseproxy_github_example_com:10m rate=100r/s;

        management:
          add_zone: "lib/reverseproxy_db.sh::add_rate_limit_zone()"
          remove_zone: "lib/reverseproxy_db.sh::remove_rate_limit_zone()"

    critical_note: "Missing rate limit zone definition causes Nginx crash loop"

  mtproxy_config:
    path: "/opt/vless/config/mtproxy/mtproxy_config.json"
    format: "JSON"
    purpose: "MTProxy server configuration (v6.0+)"
    critical: true
    feature_version: "v6.0+ (planned)"
    implementation_status: "PLANNED (not yet implemented)"
    reload_method: "Docker restart (full restart required)"
    reload_command: "docker restart vless_mtproxy"
    generator_module: "lib/mtproxy_manager.sh"
    generator_function: "generate_mtproxy_config()"

    schema:
      port:
        type: "integer"
        default: 8443
        description: "Public port for MTProxy traffic"

      workers:
        type: "integer"
        default: 2
        description: "Number of worker processes"

      stats_port:
        type: "integer"
        default: 8443
        description: "Statistics endpoint port"

      stats_path:
        type: "string"
        default: "/stats"
        description: "Statistics endpoint path"

      secrets_file:
        type: "string"
        default: "/etc/mtproxy/proxy-secret"
        description: "Path to secrets file"

      multi_conf_file:
        type: "string"
        default: "/etc/mtproxy/proxy-multi.conf"
        description: "Path to Telegram DC addresses file"

    example_config:
      port: 8443
      workers: 2
      stats_port: 8443
      stats_path: "/stats"
      secrets_file: "/etc/mtproxy/proxy-secret"
      multi_conf_file: "/etc/mtproxy/proxy-multi.conf"

  mtproxy_secrets:
    path: "/opt/vless/config/mtproxy/proxy-secret"
    format: "Plain text (one secret per line)"
    purpose: "MTProxy authentication secrets"
    critical: true
    feature_version: "v6.0+ (planned)"
    implementation_status: "PLANNED (not yet implemented)"

    format_description:
      v6_0_single_user:
        lines: 1
        format: "32 hex characters (standard secret)"
        example: "dd1234567890abcdef1234567890abcdef"
        description: "Single secret for all users (v6.0 basic mode)"

      v6_1_multi_user:
        lines: "1-50 (one per user)"
        format: "40 hex characters (ee prefix for fake-TLS)"
        examples:
          standard: "dd1234567890abcdef1234567890abcdef12345678"
          fake_tls: "ee1234567890abcdef1234567890abcdef12345678"
        description: "One unique secret per user (v6.1 multi-user mode)"

    secret_types:
      standard:
        prefix: "dd"
        description: "Standard MTProxy secret (transport obfuscation only)"
        length: "32 hex chars"

      fake_tls:
        prefix: "ee"
        description: "Fake-TLS secret (additional stealth, appears as TLS)"
        length: "40 hex chars (ee + 38 hex)"
        feature_version: "v6.1+"

    operations:
      add_secret:
        function: "lib/mtproxy_secret_manager.sh::generate_mtproxy_secret()"
        feature_version: "v6.0+"
        side_effects:
          - "Append secret to proxy-secret file"
          - "Restart MTProxy container"

      add_user_secret:
        function: "lib/mtproxy_manager.sh::add_mtproxy_user()"
        feature_version: "v6.1+"
        steps:
          - "Generate unique 40-char secret"
          - "Add to users.json: users[].mtproxy_secret"
          - "Append to proxy-secret file"
          - "Restart MTProxy container"

      remove_secret:
        function: "lib/mtproxy_secret_manager.sh::remove_mtproxy_secret()"
        feature_version: "v6.0+"
        side_effects:
          - "Remove secret from proxy-secret file"
          - "Restart MTProxy container"

    data_sources:
      - file: "/opt/vless/data/users.json"
        field: "users[].mtproxy_secret"
        feature_version: "v6.1+"
        mapping: "users[].mtproxy_secret → proxy-secret (append)"

  mtproxy_multi_conf:
    path: "/opt/vless/config/mtproxy/proxy-multi.conf"
    format: "MTProxy multi.conf format"
    purpose: "Telegram Data Center addresses"
    critical: true
    feature_version: "v6.0+ (planned)"
    source: "Official Telegram MTProxy repository"
    update_frequency: "Rarely (only when Telegram adds new DCs)"

    description: "Contains IP addresses of Telegram Data Centers for MTProxy routing"

    management:
      update_source: "https://core.telegram.org/getProxyConfig"
      update_command: "curl -s https://core.telegram.org/getProxyConfig > proxy-multi.conf"
      update_trigger: "Manual or on Telegram DC changes (rare)"

  certbot_nginx_conf:
    path: "/opt/vless/config/certbot_nginx.conf"
    format: "Nginx configuration format"
    purpose: "Temporary HTTP server for ACME HTTP-01 challenges"
    critical: true
    usage: "On-demand (only during certificate acquisition)"

    content: |
      events { worker_connections 1024; }
      http {
        server {
          listen 80;
          server_name _;
          location /.well-known/acme-challenge/ {
            root /var/www/certbot;
          }
        }
      }

  fake_site_nginx_conf:
    path: "/opt/vless/config/fake_site_nginx.conf"
    format: "Nginx configuration format"
    purpose: "Fallback website configuration"
    critical: false

    content: |
      events { worker_connections 1024; }
      http {
        server {
          listen 80;
          server_name _;
          root /usr/share/nginx/html;
          index index.html;
          location / {
            try_files $uri $uri/ =404;
          }
        }
      }

configuration_relationships:
  users_json_to_xray_config:
    source: "/opt/vless/data/users.json"
    target: "/opt/vless/config/xray_config.json"
    mapping:
      - "users[].uuid → inbounds[vless].settings.clients[].id"
      - "users[].email → inbounds[vless].settings.clients[].email"
      - "users[].username → inbounds[socks/http].settings.accounts[].user"
      - "users[].uuid → inbounds[socks/http].settings.accounts[].pass"
      - "users[].external_proxy_id → routing.rules[].user[]"
    trigger: "add-user, remove-user, set-proxy commands"
    propagation: "Regenerate xray_config.json → Reload Xray (SIGHUP)"
    downtime: "~0s (graceful reload)"

  external_proxy_json_to_xray_config:
    source: "/opt/vless/config/external_proxy.json"
    target: "/opt/vless/config/xray_config.json"
    mapping:
      - "proxies[].address → outbounds[external-proxy].settings.servers[].address"
      - "proxies[].port → outbounds[external-proxy].settings.servers[].port"
      - "proxies[].username → outbounds[external-proxy].settings.servers[].users[].user"
      - "proxies[].password → outbounds[external-proxy].settings.servers[].users[].pass"
    trigger: "vless-external-proxy add, enable, disable commands"
    propagation: "Regenerate xray_config.json → Restart Xray container"
    downtime: "~2-5s (full restart required for outbound changes)"

  reverse_proxy_conf_to_haproxy_cfg:
    source: "/opt/vless/config/reverse-proxy/*.conf"
    target: "/opt/vless/config/haproxy.cfg"
    mapping:
      - "*.conf filename → HAProxy ACL domain"
      - "listen port → HAProxy backend port"
    trigger: "vless-proxy add, vless-proxy remove commands"
    propagation: "Regenerate haproxy.cfg → Graceful reload HAProxy"
    downtime: "~0s (seamless reload)"

  reverse_proxy_conf_to_http_context_conf:
    source: "/opt/vless/config/reverse-proxy/*.conf"
    target: "/opt/vless/config/reverse-proxy/http_context.conf"
    mapping:
      - "domain → rate limit zone name"
    trigger: "vless-proxy add, vless-proxy remove commands"
    propagation: "Update http_context.conf → Reload Nginx"
    downtime: "~0s (graceful reload)"
    critical_note: "Missing zone definition causes Nginx crash"

  letsencrypt_to_haproxy:
    source: "/etc/letsencrypt/live/${DOMAIN}/"
    target: "/opt/vless/config/haproxy.cfg"
    mapping:
      - "fullchain.pem + privkey.pem → combined.pem"
      - "combined.pem → HAProxy bind ssl crt"
    trigger: "certbot certificate renewal (automated cron)"
    propagation: "Certbot hook combines certs → Graceful reload HAProxy"
    downtime: "~0s (seamless reload)"
    automation: "Cron job every 12 hours"

  letsencrypt_to_nginx:
    source: "/etc/letsencrypt/live/<subdomain>/"
    target: "/opt/vless/config/reverse-proxy/<subdomain>.conf"
    mapping:
      - "fullchain.pem → ssl_certificate"
      - "privkey.pem → ssl_certificate_key"
    trigger: "vless-proxy add command (per-domain cert acquisition)"
    propagation: "Certbot obtains cert → Nginx reload"
    downtime: "~0s (graceful reload)"

  users_json_to_mtproxy_secrets:
    source: "/opt/vless/data/users.json"
    target: "/opt/vless/config/mtproxy/proxy-secret"
    mapping:
      - "users[].mtproxy_secret → proxy-secret (one secret per line)"
    trigger: "mtproxy add-user, mtproxy remove-user (v6.1+)"
    propagation: "Update proxy-secret file → Restart MTProxy container"
    downtime: "~2-5s (full restart required)"
    feature_version: "v6.1+ (future enhancement)"

propagation_paths:
  add_user_flow:
    trigger: "sudo vless add-user <username>"
    affected_files:
      - "/opt/vless/data/users.json (add user record)"
      - "/opt/vless/config/xray_config.json (add client to inbounds)"
      - "/opt/vless/data/clients/<username>/ (generate configs)"
    services_reloaded:
      - "vless_xray (SIGHUP - graceful)"
    duration: "~3-5 seconds"
    downtime: "0s"

  remove_user_flow:
    trigger: "sudo vless remove-user <username>"
    affected_files:
      - "/opt/vless/data/users.json (remove user record)"
      - "/opt/vless/config/xray_config.json (remove client from inbounds)"
      - "/opt/vless/data/clients/<username>/ (delete directory)"
    services_reloaded:
      - "vless_xray (SIGHUP - graceful)"
    duration: "~2-3 seconds"
    downtime: "0s"

  set_user_proxy_flow:
    trigger: "sudo vless set-proxy <username> <proxy-id>"
    feature_version: "v5.24+"
    affected_files:
      - "/opt/vless/data/users.json (set external_proxy_id)"
      - "/opt/vless/config/xray_config.json (update routing.rules)"
    services_reloaded:
      - "vless_xray (SIGHUP - graceful)"
    duration: "~2-4 seconds"
    downtime: "0s"

  add_external_proxy_flow:
    trigger: "sudo vless-external-proxy add"
    feature_version: "v5.24+"
    affected_files:
      - "/opt/vless/config/external_proxy.json (add proxy record)"
      - "/opt/vless/config/xray_config.json (update outbounds)"
    services_reloaded:
      - "vless_xray (restart - outbound changes)"
    duration: "~5-10 seconds"
    downtime: "~2-5s"

  add_reverse_proxy_domain_flow:
    trigger: "sudo vless-proxy add"
    affected_files:
      - "/opt/vless/config/reverse-proxy/<domain>.conf (create Nginx config)"
      - "/opt/vless/config/reverse-proxy/http_context.conf (add rate limit zone)"
      - "/opt/vless/config/haproxy.cfg (add ACL + backend)"
      - "/etc/letsencrypt/live/<domain>/ (obtain certificate)"
    services_reloaded:
      - "vless_nginx_reverseproxy (SIGHUP - graceful)"
      - "vless_haproxy (graceful reload)"
    duration: "~30-90 seconds (cert acquisition + DNS propagation)"
    downtime: "0s"

  certificate_renewal_flow:
    trigger: "certbot renew (automated cron)"
    affected_files:
      - "/etc/letsencrypt/live/${DOMAIN}/ (renew certificates)"
      - "/etc/letsencrypt/live/${DOMAIN}/combined.pem (regenerate)"
    services_reloaded:
      - "vless_haproxy (graceful reload)"
      - "vless_nginx_reverseproxy (SIGHUP - graceful)"
    duration: "~30-60 seconds"
    downtime: "0s"
    frequency: "Every 60 days (automated)"

  mtproxy_add_user_flow:
    trigger: "sudo mtproxy add-user <username>"
    feature_version: "v6.1+ (future enhancement)"
    affected_files:
      - "/opt/vless/data/users.json (add mtproxy_secret field)"
      - "/opt/vless/config/mtproxy/proxy-secret (append secret)"
      - "/opt/vless/data/clients/<username>/mtproxy_config.txt (generate config)"
    services_reloaded:
      - "vless_mtproxy (restart - secret reload)"
    duration: "~5-10 seconds"
    downtime: "~2-5s"

atomic_operations:
  json_file_updates:
    method: "Atomic write with file locking"
    implementation:
      - "Acquire lock: flock /var/lock/vless_users.lock"
      - "Read current file"
      - "Modify in-memory JSON"
      - "Write to temporary file"
      - "Validate JSON syntax"
      - "Atomic rename: mv temp.json target.json"
      - "Release lock"
    files_using_method:
      - "/opt/vless/data/users.json"
      - "/opt/vless/config/external_proxy.json"
    timeout: "10s"

  config_file_updates:
    method: "Atomic write with validation"
    implementation:
      - "Generate new config in memory"
      - "Write to temporary file"
      - "Validate syntax (haproxy -c, xray test, nginx -t)"
      - "If valid: atomic rename"
      - "If invalid: abort, log error, keep old config"
    files_using_method:
      - "/opt/vless/config/xray_config.json"
      - "/opt/vless/config/haproxy.cfg"
      - "/opt/vless/config/reverse-proxy/*.conf"

validation_methods:
  xray_config_validation:
    command: "docker exec vless_xray xray test -c /opt/vless/config/xray_config.json"
    success_exit_code: 0
    failure_action: "Abort update, keep old config, log error"

  haproxy_config_validation:
    command: "docker exec vless_haproxy haproxy -c -f /opt/vless/config/haproxy.cfg"
    success_exit_code: 0
    failure_action: "Abort update, keep old config, log error"

  nginx_config_validation:
    command: "docker exec vless_nginx_reverseproxy nginx -t"
    success_exit_code: 0
    failure_action: "Abort update, keep old config, log error"

  json_syntax_validation:
    command: "jq . <file.json> > /dev/null"
    success_exit_code: 0
    failure_action: "Abort update, keep old config, log error"

backup_recommendations:
  critical_files:
    - file: "/opt/vless/data/users.json"
      priority: "CRITICAL"
      frequency: "Daily"
      retention: "30 days"

    - file: "/opt/vless/config/"
      priority: "HIGH"
      frequency: "Weekly"
      retention: "30 days"

    - file: "/etc/letsencrypt/"
      priority: "HIGH"
      frequency: "Weekly"
      retention: "90 days"

  backup_method: "Automated cron job with rsync or tar"
  restore_procedure: "Documented in docs/prd/06_appendix.md"

troubleshooting:
  common_issues:
    xray_config_syntax_error:
      symptom: "Xray container unhealthy or won't start"
      detection: "docker logs vless_xray | grep 'syntax error'"
      fix: "Validate xray_config.json with jq, check for malformed JSON"

    haproxy_config_syntax_error:
      symptom: "HAProxy container won't start or reload fails"
      detection: "docker exec vless_haproxy haproxy -c -f /opt/vless/config/haproxy.cfg"
      fix: "Check haproxy.cfg syntax, validate ACL format"

    nginx_crash_loop:
      symptom: "vless_nginx_reverseproxy keeps restarting"
      detection: "docker logs vless_nginx_reverseproxy | grep 'unknown zone'"
      cause: "Missing rate limit zone in http_context.conf"
      fix: "Add missing limit_req_zone to http_context.conf, reload Nginx"

    missing_certificate:
      symptom: "HAProxy won't start, missing combined.pem"
      detection: "docker logs vless_haproxy | grep 'unable to load SSL certificate'"
      cause: "Certificate not combined or missing"
      fix: "Run: cat fullchain.pem privkey.pem > combined.pem"

    users_json_corrupted:
      symptom: "Cannot add/remove users, JSON parse errors"
      detection: "jq . /opt/vless/data/users.json (exit code != 0)"
      cause: "Malformed JSON, race condition, disk full"
      fix: "Restore from backup, validate JSON syntax"

references:
  documentation:
    - "docs/prd/04_architecture.md - Configuration architecture details"
    - "docs/prd/02_functional_requirements.md - Configuration requirements"
    - "docs/prd/06_appendix.md - Troubleshooting and rollback procedures"
    - "CLAUDE.md - Project memory and quick reference"

  generator_modules:
    - "lib/orchestrator.sh::generate_xray_config()"
    - "lib/haproxy_config_manager.sh::generate_haproxy_config()"
    - "lib/reverseproxy_db.sh::add_reverse_proxy_domain()"
    - "lib/user_management.sh::add_user_to_json()"
    - "lib/external_proxy_manager.sh::add_external_proxy()"
    - "lib/mtproxy_manager.sh::generate_mtproxy_config() (v6.0+)"

notes:
  - "All configuration changes use atomic writes (temp file → rename)"
  - "All JSON modifications protected by file locking (flock)"
  - "Configuration validation ALWAYS performed before applying"
  - "Graceful reloads preferred (HAProxy, Xray, Nginx) to minimize downtime"
  - "users.json is single source of truth for all user-related configs"
  - "external_proxy.json is optional (v5.24+ feature)"
  - "MTProxy configs are planned (v6.0+), not yet implemented"
  - "Rate limit zones MUST be in http_context.conf, not server blocks"
  - "Missing rate limit zone causes Nginx crash loop (common issue)"
