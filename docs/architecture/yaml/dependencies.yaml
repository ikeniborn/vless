version: "1.0"
documentation_version: "v5.26"
last_updated: "2026-01-07"

project:
  name: "VLESS + Reality VPN - Dependencies Architecture"
  version: "v5.26"
  description: "Comprehensive documentation of module dependencies, initialization order, runtime dependencies, and critical execution paths"

initialization_order:
  installation_phase:
    total_steps: 15
    estimated_duration: "~5-7 minutes (fresh Ubuntu 22.04)"

    steps:
      - order: 1
        module: "os_detection.sh"
        function: "detect_os()"
        purpose: "Detect Ubuntu/Debian version and validate compatibility"
        duration: "< 1s"
        validation:
          - check: "OS is Ubuntu 20.04+ or Debian 10+"
          - check: "64-bit architecture"
        on_failure: "EXIT with error (unsupported OS)"
        dependencies: []

      - order: 2
        module: "dependencies.sh"
        function: "install_system_dependencies()"
        purpose: "Install required system packages (docker, jq, certbot, etc.)"
        duration: "~60-120s"
        packages:
          - "docker.io"
          - "docker-compose"
          - "jq"
          - "qrencode"
          - "certbot"
          - "ufw"
          - "fail2ban"
          - "curl"
          - "wget"
          - "openssl"
        validation:
          - check: "Each package installed successfully"
          - check: "Docker service running"
        on_failure: "RETRY package installation or EXIT"
        depends_on: ["os_detection.sh"]

      - order: 3
        module: "interactive_params.sh"
        function: "collect_installation_params()"
        purpose: "Collect installation parameters via interactive wizard"
        duration: "~60-180s (user input time)"
        prompts:
          - "Domain name (FQDN)"
          - "Email address (for Let's Encrypt)"
          - "DNS server (default: 8.8.8.8)"
          - "Install MTProxy? (v6.0+, default: no)"
        outputs:
          - "DOMAIN"
          - "EMAIL"
          - "DNS"
          - "INSTALL_MTPROXY"
        validation:
          - check: "Domain is valid FQDN"
          - check: "Email is valid format"
        on_failure: "ASK user to re-enter"
        depends_on: ["dependencies.sh"]

      - order: 4
        module: "certificate_manager.sh"
        function: "validate_dns_for_domain()"
        purpose: "Verify domain DNS points to server IP"
        duration: "~5-10s"
        checks:
          - "dig +short <domain> returns server IP"
          - "DNS propagation complete"
        validation:
          - check: "DNS A record matches server IP"
        on_failure: "EXIT with error (fix DNS first)"
        depends_on: ["interactive_params.sh"]

      - order: 5
        module: "certificate_manager.sh"
        function: "obtain_certificate()"
        purpose: "Obtain Let's Encrypt certificate via ACME HTTP-01"
        duration: "~30-60s"
        workflow:
          - "Start vless_certbot_nginx container (port 80)"
          - "Run certbot certonly --webroot"
          - "Wait for ACME challenge"
          - "Stop vless_certbot_nginx"
          - "Combine fullchain + privkey → combined.pem"
        outputs:
          - "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem"
          - "/etc/letsencrypt/live/${DOMAIN}/privkey.pem"
          - "/etc/letsencrypt/live/${DOMAIN}/combined.pem"
        validation:
          - check: "Certificate files exist"
          - check: "Certificate valid for 90 days"
        on_failure: "RETRY or EXIT"
        depends_on: ["certificate_manager.sh::validate_dns_for_domain()"]

      - order: 6
        module: "docker_compose_generator.sh"
        function: "generate_docker_compose()"
        purpose: "Generate docker-compose.yml from installation parameters"
        duration: "< 1s"
        writes: "/opt/vless/docker-compose.yml"
        validation:
          - check: "docker-compose config (syntax validation)"
        on_failure: "EXIT with error (template corruption)"
        depends_on: ["interactive_params.sh", "certificate_manager.sh"]

      - order: 7
        module: "haproxy_config_manager.sh"
        function: "generate_haproxy_config()"
        purpose: "Generate HAProxy configuration"
        duration: "< 1s"
        writes: "/opt/vless/config/haproxy.cfg"
        sections:
          - "global"
          - "defaults"
          - "frontends (https_sni_router, socks5_tls, http_tls, stats)"
          - "backends (xray_vless, xray_socks5, xray_http, fake_site)"
        validation:
          - check: "haproxy -c -f haproxy.cfg (syntax check)"
        on_failure: "EXIT with error"
        depends_on: ["interactive_params.sh"]

      - order: 8
        module: "orchestrator.sh"
        function: "generate_xray_config()"
        purpose: "Generate initial Xray configuration (no users yet)"
        duration: "< 1s"
        writes: "/opt/vless/config/xray_config.json"
        reads: "/opt/vless/data/users.json (empty initially)"
        validation:
          - check: "xray test -c config.json"
        on_failure: "EXIT with error"
        depends_on: ["interactive_params.sh"]

      - order: 9
        module: "security_hardening.sh"
        function: "configure_ufw()"
        purpose: "Configure UFW firewall rules"
        duration: "~5-10s"
        rules:
          - "ufw allow 22/tcp (SSH)"
          - "ufw allow 443/tcp (HTTPS/TLS)"
          - "ufw allow 1080/tcp (SOCKS5)"
          - "ufw allow 8118/tcp (HTTP proxy)"
          - "ufw allow 8443/tcp (MTProxy, v6.0+)"
          - "ufw default deny incoming"
          - "ufw default allow outgoing"
          - "ufw enable"
        validation:
          - check: "ufw status shows active"
          - check: "Required ports allowed"
        on_failure: "WARN (continue without UFW)"
        depends_on: ["docker_compose_generator.sh"]

      - order: 10
        module: "security_hardening.sh"
        function: "configure_fail2ban()"
        purpose: "Configure fail2ban jails"
        duration: "~5-10s"
        jails:
          - "sshd"
          - "haproxy"
        validation:
          - check: "fail2ban-client status"
        on_failure: "WARN (continue without fail2ban)"
        depends_on: ["configure_ufw()"]

      - order: 11
        module: "security_hardening.sh"
        function: "set_file_permissions()"
        purpose: "Set secure file permissions on config files"
        duration: "< 1s"
        operations:
          - "chmod 600 /opt/vless/data/users.json"
          - "chmod 600 /opt/vless/config/external_proxy.json"
          - "chmod 644 /opt/vless/config/*.json *.cfg"
          - "chown root:root /opt/vless/config/*"
        validation:
          - check: "Permissions set correctly"
        on_failure: "WARN (continue)"
        depends_on: ["generate_xray_config()", "generate_haproxy_config()"]

      - order: 12
        module: "container_manager.sh"
        function: "start_docker_containers()"
        purpose: "Start all Docker containers via docker-compose up -d"
        duration: "~10-30s (image pull + container start)"
        command: "docker-compose -f /opt/vless/docker-compose.yml up -d"
        containers_started:
          - "vless_haproxy"
          - "vless_xray"
          - "vless_nginx_reverseproxy"
          - "vless_fake_site"
          - "vless_mtproxy (v6.0+, conditional)"
        validation:
          - check: "All containers running"
          - check: "Health checks passing (wait up to 30s)"
        on_failure: "EXIT with error (check docker logs)"
        depends_on: ["docker_compose_generator.sh", "generate_haproxy_config()", "generate_xray_config()"]

      - order: 13
        module: "letsencrypt_integration.sh"
        function: "setup_renewal_cron()"
        purpose: "Setup automated certificate renewal cron job"
        duration: "< 1s"
        cron_entry: "0 */12 * * * certbot renew --quiet --post-hook 'reload_haproxy && reload_nginx'"
        validation:
          - check: "Cron job added"
        on_failure: "WARN (manual renewal required)"
        depends_on: ["certificate_manager.sh"]

      - order: 14
        module: "user_management.sh"
        function: "add_first_user()"
        purpose: "Add first VPN user via interactive prompt"
        duration: "~5-10s (user input + config generation)"
        prompts:
          - "First username"
        operations:
          - "add_user_to_json()"
          - "generate_xray_config()"
          - "reload_xray()"
          - "generate_client_configs()"
        outputs:
          - "/opt/vless/data/users.json (first user)"
          - "/opt/vless/data/clients/<username>/ (configs)"
        validation:
          - check: "User added successfully"
          - check: "Xray reloaded"
        on_failure: "WARN (user can add manually later)"
        depends_on: ["container_manager.sh"]

      - order: 15
        module: "orchestrator.sh"
        function: "display_installation_summary()"
        purpose: "Display installation summary and next steps"
        duration: "< 1s"
        output:
          - "Installation successful message"
          - "Server information (domain, IP, ports)"
          - "First user credentials (QR codes, URIs)"
          - "Next steps (add more users, reverse proxy, etc.)"
        depends_on: ["user_management.sh::add_first_user()"]

  critical_path:
    steps:
      - "os_detection → dependencies → interactive_params → validate_dns → obtain_certificate → generate_docker_compose → generate_haproxy_config → generate_xray_config → start_containers → add_first_user"
    total_duration: "~5-7 minutes (typical)"
    bottlenecks:
      - "install_system_dependencies() (~60-120s, network-dependent)"
      - "obtain_certificate() (~30-60s, DNS + ACME challenge)"
      - "start_docker_containers() (~10-30s, image pull)"
      - "user input (interactive_params, add_first_user) (variable)"

runtime_dependencies:
  user_operations:
    add_user:
      entry_point: "vless add-user <username>"
      depends_on:
        files_exist:
          - "/opt/vless/data/users.json"
          - "/opt/vless/config/xray_config.json"
        services_running:
          - "vless_xray (healthy)"
        modules:
          - "lib/user_management.sh"
          - "lib/orchestrator.sh (generate_xray_config)"
          - "lib/qr_generator.sh"
      calls:
        - "add_user_to_json() → generate_xray_config() → reload_xray() → generate_client_configs()"
      validation:
        - check: "Username unique"
        - check: "UUID valid (UUIDv4)"
        - check: "xray_config.json valid after regeneration"
        - check: "Xray reload successful"

    remove_user:
      entry_point: "vless remove-user <username>"
      depends_on:
        files_exist:
          - "/opt/vless/data/users.json"
          - "/opt/vless/config/xray_config.json"
        services_running:
          - "vless_xray (healthy)"
        modules:
          - "lib/user_management.sh"
          - "lib/orchestrator.sh"
      calls:
        - "remove_user_from_json() → generate_xray_config() → reload_xray()"
      validation:
        - check: "User exists"
        - check: "Not deleting last user"
        - check: "Xray reload successful"

    set_user_proxy:
      entry_point: "vless set-proxy <username> <proxy-id>"
      feature_version: "v5.24+"
      depends_on:
        files_exist:
          - "/opt/vless/data/users.json"
          - "/opt/vless/config/external_proxy.json"
          - "/opt/vless/config/xray_config.json"
        services_running:
          - "vless_xray (healthy)"
        modules:
          - "lib/user_management.sh"
          - "lib/xray_routing_manager.sh"
          - "lib/orchestrator.sh"
      calls:
        - "update_user_proxy_id() → update_xray_routing_for_user() → generate_xray_config() → reload_xray()"
      validation:
        - check: "User exists"
        - check: "Proxy exists in external_proxy.json"
        - check: "Proxy enabled"
        - check: "xray_config.json valid"

  external_proxy_operations:
    add_external_proxy:
      entry_point: "vless-external-proxy add"
      feature_version: "v5.24+"
      depends_on:
        files_exist:
          - "/opt/vless/config/external_proxy.json (create if not exists)"
          - "/opt/vless/config/xray_config.json"
        services_running:
          - "vless_xray (healthy)"
        modules:
          - "lib/external_proxy_manager.sh"
          - "lib/orchestrator.sh"
      calls:
        - "add_proxy_to_json() → generate_xray_config() → docker restart vless_xray"
      validation:
        - check: "Proxy connectivity (curl via proxy)"
        - check: "xray_config.json valid"
      side_effects:
        - "Xray restart (~2-5s downtime)"

  reverse_proxy_operations:
    add_reverse_proxy_domain:
      entry_point: "vless-proxy add"
      feature_version: "v4.3+"
      depends_on:
        files_exist:
          - "/opt/vless/config/reverse-proxy/ (directory)"
          - "/opt/vless/config/reverse-proxy/http_context.conf"
          - "/opt/vless/config/haproxy.cfg"
        services_running:
          - "vless_haproxy (healthy)"
          - "vless_nginx_reverseproxy (healthy)"
        modules:
          - "lib/reverseproxy_db.sh"
          - "lib/haproxy_config_manager.sh"
          - "lib/certificate_manager.sh"
      calls:
        - "validate_dns_for_domain() → allocate_port() → obtain_certificate() → generate_nginx_config() → add_rate_limit_zone() → reload_nginx() → add_haproxy_acl_for_domain() → reload_haproxy()"
      validation:
        - check: "Domain DNS points to server"
        - check: "Port available (9443-9452 pool)"
        - check: "Certificate obtained"
        - check: "Nginx config valid"
        - check: "HAProxy config valid"
      critical_note: "Missing rate limit zone causes Nginx crash"

module_dependency_graph:
  nodes:
    - id: "orchestrator.sh"
      type: "coordinator"
      criticality: "CRITICAL"
      dependencies: ["dependencies.sh", "interactive_params.sh", "docker_compose_generator.sh", "haproxy_config_manager.sh", "certificate_manager.sh"]
      initialization_order: 1

    - id: "user_management.sh"
      type: "domain_logic"
      criticality: "CRITICAL"
      dependencies: ["xray_routing_manager.sh", "qr_generator.sh", "client_config_generator.sh", "orchestrator.sh"]
      initialization_order: 5

    - id: "external_proxy_manager.sh"
      type: "domain_logic"
      criticality: "HIGH"
      feature_version: "v5.24+"
      dependencies: ["xray_routing_manager.sh", "orchestrator.sh"]
      initialization_order: 6

    - id: "reverseproxy_db.sh"
      type: "domain_logic"
      criticality: "HIGH"
      feature_version: "v4.3+"
      dependencies: ["haproxy_config_manager.sh", "certificate_manager.sh"]
      initialization_order: 7

    - id: "xray_routing_manager.sh"
      type: "config_generator"
      criticality: "HIGH"
      feature_version: "v5.24+"
      dependencies: []
      initialization_order: 4

    - id: "haproxy_config_manager.sh"
      type: "config_generator"
      criticality: "CRITICAL"
      dependencies: []
      initialization_order: 2

    - id: "certificate_manager.sh"
      type: "infrastructure"
      criticality: "CRITICAL"
      dependencies: []
      initialization_order: 3

    - id: "docker_compose_generator.sh"
      type: "infrastructure"
      criticality: "CRITICAL"
      dependencies: []
      initialization_order: 2

    - id: "qr_generator.sh"
      type: "utility"
      criticality: "MEDIUM"
      dependencies: ["qrencode (system)"]
      initialization_order: 8

    - id: "security_hardening.sh"
      type: "infrastructure"
      criticality: "HIGH"
      dependencies: ["ufw", "fail2ban"]
      initialization_order: 3

  edges:
    - from: "orchestrator.sh"
      to: "dependencies.sh"
      type: "initialization"
      purpose: "Install system packages first"

    - from: "orchestrator.sh"
      to: "interactive_params.sh"
      type: "initialization"
      purpose: "Collect installation parameters"

    - from: "orchestrator.sh"
      to: "certificate_manager.sh"
      type: "initialization"
      purpose: "Obtain SSL certificates"

    - from: "orchestrator.sh"
      to: "docker_compose_generator.sh"
      type: "initialization"
      purpose: "Generate docker-compose.yml"

    - from: "orchestrator.sh"
      to: "haproxy_config_manager.sh"
      type: "initialization"
      purpose: "Generate HAProxy config"

    - from: "user_management.sh"
      to: "orchestrator.sh"
      type: "runtime_call"
      when: "add-user, remove-user, set-proxy commands"
      purpose: "Regenerate Xray config"

    - from: "user_management.sh"
      to: "xray_routing_manager.sh"
      type: "runtime_call"
      when: "set-proxy command"
      purpose: "Update routing rules"

    - from: "user_management.sh"
      to: "qr_generator.sh"
      type: "runtime_call"
      when: "add-user command"
      purpose: "Generate client configs"

    - from: "external_proxy_manager.sh"
      to: "xray_routing_manager.sh"
      type: "runtime_call"
      when: "proxy-related commands"
      purpose: "Update routing rules"

    - from: "external_proxy_manager.sh"
      to: "orchestrator.sh"
      type: "runtime_call"
      when: "add/remove/enable/disable proxy"
      purpose: "Regenerate Xray config"

    - from: "reverseproxy_db.sh"
      to: "certificate_manager.sh"
      type: "runtime_call"
      when: "add reverse proxy domain"
      purpose: "Obtain SSL certificate"

    - from: "reverseproxy_db.sh"
      to: "haproxy_config_manager.sh"
      type: "runtime_call"
      when: "add/remove reverse proxy domain"
      purpose: "Update HAProxy ACLs"

  diagram_reference: "diagrams/dependencies/module-dependencies.md"

critical_paths:
  installation:
    path:
      - "os_detection → dependencies → interactive_params → validate_dns → obtain_certificate → generate_docker_compose → generate_haproxy_config → generate_xray_config → configure_ufw → start_containers → add_first_user"
    duration: "~5-7 minutes (typical)"
    bottlenecks:
      - step: "install_system_dependencies"
        duration: "~60-120s"
        network_dependent: true
      - step: "obtain_certificate"
        duration: "~30-60s"
        dns_dependent: true
      - step: "start_docker_containers"
        duration: "~10-30s"
        docker_hub_dependent: true

  add_user:
    path:
      - "validate_username → add_user_to_json → generate_xray_config → validate_xray_config → reload_xray → generate_qr_code"
    duration: "~3-5 seconds"
    bottlenecks:
      - step: "generate_xray_config"
        duration: "~500ms (50+ users) or ~100ms (few users)"
      - step: "generate_qr_code"
        duration: "~1-2s (6 QR codes)"

  set_user_proxy:
    path:
      - "validate_user → validate_proxy → update_user_proxy_id → update_xray_routing_for_user → generate_xray_config → validate_xray_config → reload_xray"
    duration: "~2-4 seconds"
    bottlenecks:
      - step: "generate_xray_config"
        duration: "~500ms"

  add_reverse_proxy_domain:
    path:
      - "validate_domain_dns → allocate_port → obtain_certificate → generate_nginx_config → add_rate_limit_zone → reload_nginx → add_haproxy_acl → reload_haproxy"
    duration: "~60-90 seconds"
    bottlenecks:
      - step: "obtain_certificate"
        duration: "~30-60s"
        acme_dependent: true

  add_external_proxy:
    path:
      - "collect_proxy_details → test_connectivity → add_proxy_to_json → generate_xray_config → docker restart vless_xray"
    duration: "~10-20 seconds"
    bottlenecks:
      - step: "test_connectivity"
        duration: "~5-10s"
        proxy_dependent: true
      - step: "docker restart vless_xray"
        duration: "~2-5s"
        downtime: true

validation_checkpoints:
  installation:
    checkpoint_1:
      after_step: "os_detection"
      checks:
        - "OS is supported (Ubuntu 20.04+ or Debian 10+)"
        - "Architecture is x86_64"
      on_failure: "EXIT (unsupported system)"

    checkpoint_2:
      after_step: "install_system_dependencies"
      checks:
        - "All packages installed"
        - "Docker service running"
        - "Docker version >= 20.10"
      on_failure: "RETRY installation or EXIT"

    checkpoint_3:
      after_step: "collect_installation_params"
      checks:
        - "Domain is valid FQDN"
        - "Email is valid format"
        - "DNS is valid IP"
      on_failure: "ASK user to re-enter"

    checkpoint_4:
      after_step: "obtain_certificate"
      checks:
        - "Certificate files exist"
        - "Certificate valid for 90 days"
        - "combined.pem created"
      on_failure: "RETRY or EXIT"

    checkpoint_5:
      after_step: "start_docker_containers"
      checks:
        - "All containers running"
        - "Health checks passing"
        - "Ports listening (443, 1080, 8118)"
      on_failure: "CHECK logs, RETRY, or EXIT"

  runtime:
    user_add_checkpoint:
      before_operation: "add_user_to_json"
      checks:
        - "Username format valid"
        - "Username unique"
        - "users.json readable and writable"
      on_failure: "ABORT operation"

    user_add_post_checkpoint:
      after_operation: "reload_xray"
      checks:
        - "Xray container healthy"
        - "xray_config.json valid"
        - "Client configs generated"
      on_failure: "ROLLBACK (remove user from users.json)"

    reverse_proxy_checkpoint:
      after_operation: "add_rate_limit_zone"
      checks:
        - "Rate limit zone added to http_context.conf"
        - "Nginx config valid (nginx -t)"
      on_failure: "ABORT operation, REMOVE Nginx config"
      critical_note: "Missing zone causes Nginx crash loop"

failure_recovery:
  installation_failure:
    scenario: "Installation fails at any step"
    recovery_strategy:
      - "Log detailed error message"
      - "Preserve partial state (configs, logs)"
      - "Provide manual cleanup instructions"
      - "Allow re-run from failed step (if possible)"
    rollback: "Manual (delete /opt/vless/, containers, configs)"

  xray_reload_failure:
    scenario: "Xray reload fails after config change"
    recovery_strategy:
      - "Preserve old xray_config.json (backup)"
      - "Restore from backup"
      - "Reload Xray with old config"
      - "Alert user to fix issue"
    rollback: "Automatic (restore previous config)"

  haproxy_reload_failure:
    scenario: "HAProxy reload fails after config change"
    recovery_strategy:
      - "Preserve old haproxy.cfg (backup)"
      - "Validate config syntax before reload"
      - "If validation fails, abort operation"
      - "Keep old config active"
    rollback: "Automatic (abort before reload)"

  nginx_crash_loop:
    scenario: "Nginx crashes due to missing rate limit zone"
    recovery_strategy:
      - "Detect crash loop (restarts > 3 in 5 minutes)"
      - "Check http_context.conf for missing zones"
      - "Add missing zones automatically"
      - "Reload Nginx"
    rollback: "Automatic (fix http_context.conf)"

  certificate_renewal_failure:
    scenario: "Certbot renewal fails"
    recovery_strategy:
      - "Log error (email notification if configured)"
      - "Retry on next cron run (12 hours)"
      - "Alert user if < 7 days to expiration"
      - "Manual renewal instructions"
    rollback: "N/A (old certificate still valid)"

concurrency_control:
  file_locks:
    users_json:
      lock_file: "/var/lock/vless_users.lock"
      operations:
        - "add_user_to_json()"
        - "remove_user_from_json()"
        - "update_user_proxy_id()"
      timeout: "10s"
      on_timeout: "ABORT with error (try again later)"

    external_proxy_json:
      lock_file: "/var/lock/vless_external_proxy.lock"
      operations:
        - "add_proxy_to_json()"
        - "remove_proxy_from_json()"
        - "toggle_proxy_enabled()"
      timeout: "10s"

    config_generation:
      lock_file: "/var/lock/vless_config_generation.lock"
      operations:
        - "generate_xray_config()"
        - "generate_haproxy_config()"
      timeout: "30s"
      note: "Longer timeout for config generation"

  race_condition_prevention:
    scenario: "Two users run 'vless add-user' simultaneously"
    prevention:
      - "flock ensures exclusive access to users.json"
      - "First command acquires lock, second waits"
      - "Atomic write (temp file → rename) prevents corruption"
    worst_case: "Second command waits up to 10s for lock"

service_dependencies:
  docker_containers:
    vless_haproxy:
      depends_on:
        - "vless_xray (must be healthy for backend routing)"
        - "vless_nginx_reverseproxy (optional, for reverse proxy)"
        - "vless_fake_site (for fallback)"
      health_check: "haproxy -c -f /usr/local/etc/haproxy/haproxy.cfg"
      restart_policy: "unless-stopped"

    vless_xray:
      depends_on: []
      health_check: "xray version"
      restart_policy: "unless-stopped"
      critical: true

    vless_nginx_reverseproxy:
      depends_on:
        - "/etc/letsencrypt/ (for SSL certificates)"
      health_check: "nginx -t"
      restart_policy: "unless-stopped"

    vless_fake_site:
      depends_on: []
      health_check: "wget --spider http://localhost/"
      restart_policy: "unless-stopped"

    vless_mtproxy:
      depends_on: []
      health_check: "curl http://localhost:8443/stats"
      restart_policy: "unless-stopped"
      feature_version: "v6.0+ (planned)"

  service_start_order:
    - order: 1
      services: ["vless_xray", "vless_fake_site"]
      reason: "No dependencies, can start first"

    - order: 2
      services: ["vless_nginx_reverseproxy"]
      reason: "Depends on certificates (already available)"

    - order: 3
      services: ["vless_haproxy"]
      reason: "Depends on all backends being ready"

    - order: 4
      services: ["vless_mtproxy"]
      reason: "Independent, can start anytime"

performance_impact:
  config_generation:
    users_json_size:
      small: "< 10 users"
      medium: "10-50 users"
      large: "> 50 users"
    impact_on_generate_xray_config:
      small: "~100ms"
      medium: "~300ms"
      large: "~500-1000ms"
    recommendation: "Keep users < 100 for optimal performance"

  reverse_proxy_domains:
    max_domains: 10
    reason: "Limited port pool (9443-9452)"
    impact_on_haproxy_config_generation:
      1_domain: "~50ms"
      5_domains: "~150ms"
      10_domains: "~300ms"

  external_proxies:
    max_proxies: 10
    recommendation: "5 or fewer for manageability"
    impact_on_xray_restart:
      add_proxy: "~2-5s downtime"
      reason: "Outbound changes require full restart"

references:
  diagrams:
    - "diagrams/dependencies/module-dependencies.md - Module dependency graph"
    - "diagrams/dependencies/initialization-order.md - Installation flow"
    - "diagrams/dependencies/runtime-call-chains.md - Runtime function calls"

  documentation:
    - "docs/prd/04_architecture.md - Architecture details"
    - "docs/architecture/yaml/lib-modules.yaml - Module documentation"
    - "docs/architecture/yaml/cli.yaml - CLI commands"
    - "CLAUDE.md - Project memory"

notes:
  - "Installation follows strict sequential order (15 steps)"
  - "Runtime operations use file locking for concurrency control"
  - "All critical operations have validation checkpoints"
  - "Failure recovery strategies defined for common scenarios"
  - "Service start order matters (Xray before HAProxy)"
  - "Performance impact documented for scaling decisions"
  - "MTProxy dependencies are v6.0+ (planned, not implemented)"
