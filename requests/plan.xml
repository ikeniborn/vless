<?xml version="1.0" encoding="UTF-8"?>
<implementation_plan>
    <project_info>
        <name>VLESS+Reality VPN - Enhanced Chrony Time Synchronization Fix</name>
        <version>1.2.5</version>
        <description>Implementation plan to fix chrony time synchronization issues causing APT repository errors</description>
        <target_file>/home/ikeniborn/Documents/Project/vless/modules/common_utils.sh</target_file>
    </project_info>

    <problem_summary>
        <issue>APT repository updates fail with "Release file... is not valid yet" errors due to system time being 8-10 minutes behind actual time</issue>
        <root_cause>Chrony reports success but doesn't actually synchronize time - shows unreachable NTP server with Stratum 0</root_cause>
        <selected_solution>Enhanced Chrony Configuration with multiple NTP servers, proper verification, and extended wait times</selected_solution>
    </problem_summary>

    <implementation_tasks>
        <task id="1" priority="critical">
            <name>Enhance chrony configuration with multiple reliable NTP servers</name>
            <description>Modify configure_chrony_for_large_offset() to include multiple reliable NTP servers and proper configuration</description>
            <target_function>configure_chrony_for_large_offset()</target_function>
            <line_range>667-710</line_range>
            <changes>
                <change type="modify">
                    <description>Add pool of reliable NTP servers to chrony configuration</description>
                    <code_block>
# Define reliable NTP server pool
local ntp_servers=(
    "pool.ntp.org"
    "time.nist.gov"
    "time.google.com"
    "time.cloudflare.com"
    "0.pool.ntp.org"
    "1.pool.ntp.org"
    "2.pool.ntp.org"
    "3.pool.ntp.org"
)

# Create comprehensive chrony configuration
cat > "$temp_conf" << EOF
# Multiple reliable NTP servers for redundancy
$(for server in "${ntp_servers[@]}"; do echo "server $server iburst"; done)

# Aggressive step settings for large offsets
makestep 1000 -1

# Allow for quick synchronization
driftfile /var/lib/chrony/chrony.drift
rtcsync
maxupdateskew 100.0

# Enable command access
cmdallow 127.0.0.1
bindcmdaddress 127.0.0.1

# Logging
logdir /var/log/chrony
EOF
                    </code_block>
                </change>
            </changes>
        </task>

        <task id="2" priority="critical">
            <name>Implement chrony synchronization status verification</name>
            <description>Add new function to verify chrony synchronization using 'chronyc tracking' and 'chronyc sources'</description>
            <target_function>verify_chrony_sync_status()</target_function>
            <line_range>new_function</line_range>
            <changes>
                <change type="add">
                    <description>Create function to verify chrony synchronization status</description>
                    <code_block>
# Verify chrony synchronization status using tracking and sources
verify_chrony_sync_status() {
    local max_retries="${1:-5}"
    local retry_delay="${2:-3}"

    log_debug "Verifying chrony synchronization status"

    for ((i=1; i<=max_retries; i++)); do
        log_debug "Verification attempt $i/$max_retries"

        # Check tracking status
        local tracking_output
        if tracking_output=$(safe_execute_output 15 chronyc tracking 2>/dev/null); then
            log_debug "Chrony tracking output: $tracking_output"

            # Parse tracking output for synchronization indicators
            if echo "$tracking_output" | grep -q "Stratum.*[1-9]"; then
                local stratum=$(echo "$tracking_output" | grep "Stratum" | awk '{print $3}')
                log_debug "Chrony synchronized with Stratum: $stratum"

                # Check if we have a valid time source
                if echo "$tracking_output" | grep -q "Reference time"; then
                    log_success "Chrony synchronization verified - Stratum $stratum active"
                    return 0
                fi
            fi
        fi

        # Check sources status for reachable servers
        local sources_output
        if sources_output=$(safe_execute_output 15 chronyc sources 2>/dev/null); then
            log_debug "Chrony sources output: $sources_output"

            # Look for active sources (marked with '*' or '+')
            if echo "$sources_output" | grep -E "^\^[\*\+]" | head -1; then
                local active_server=$(echo "$sources_output" | grep -E "^\^[\*\+]" | head -1 | awk '{print $2}')
                log_success "Chrony has active server: $active_server"
                return 0
            fi
        fi

        if [[ $i -lt $max_retries ]]; then
            log_debug "Chrony not yet synchronized, waiting ${retry_delay}s before retry $((i+1))"
            interruptible_sleep "$retry_delay" 1
        fi
    done

    log_warn "Chrony synchronization verification failed after $max_retries attempts"
    return 1
}
                    </code_block>
                </change>
            </changes>
        </task>

        <task id="3" priority="high">
            <name>Enhance sync_system_time() chrony method with proper verification</name>
            <description>Modify the chrony section in sync_system_time() to use verification and extended wait times</description>
            <target_function>sync_system_time()</target_function>
            <line_range>533-579</line_range>
            <changes>
                <change type="modify">
                    <description>Replace existing chrony sync logic with enhanced verification</description>
                    <code_block>
    # Method 4: Try chrony if available (enhanced with status verification)
    if command_exists chronyc; then
        log_debug "Attempting time sync with chrony (enhanced mode)"

        # Store current time for comparison
        local time_before=$(date +%s)
        log_debug "System time before chrony sync: $(date)"

        # Configure chrony for large step corrections with multiple servers
        if configure_chrony_for_large_offset; then
            log_debug "Chrony configured with multiple NTP servers for large offset correction"

            # Restart chrony service to apply new configuration
            if safe_execute 30 systemctl restart chrony; then
                log_debug "Chrony service restarted with new configuration"

                # Wait for service to fully start
                interruptible_sleep 3 1

                # Force immediate sync with all NTP servers using burst mode
                if safe_execute 30 chronyc burst 4/4; then
                    log_debug "Chrony burst mode initiated with 4 servers"

                    # Extended wait for burst mode to complete and synchronization to occur
                    log_debug "Waiting for chrony synchronization (20 seconds)"
                    interruptible_sleep 20 2

                    # Verify synchronization status before makestep
                    if verify_chrony_sync_status 3 5; then
                        log_success "Chrony synchronization verified before makestep"

                        # Force step adjustment with verification
                        if safe_execute 30 chronyc makestep; then
                            log_debug "Chrony makestep command executed"

                            # Wait for time adjustment to settle
                            interruptible_sleep 5 1

                            # Validate the time change
                            if validate_time_sync_result "$time_before"; then
                                log_success "Time synchronized using chrony with verified sync status"

                                # Force hardware clock update after successful chrony sync
                                if command_exists hwclock; then
                                    safe_execute 30 hwclock --systohc 2>/dev/null || true
                                    log_debug "Hardware clock updated after chrony sync"
                                fi

                                return 0
                            else
                                log_warn "Chrony makestep executed but time wasn't corrected significantly"
                            fi
                        fi
                    else
                        log_warn "Chrony synchronization verification failed, attempting makestep anyway"

                        # Try makestep even if verification failed
                        if safe_execute 30 chronyc makestep; then
                            interruptible_sleep 5 1
                            if validate_time_sync_result "$time_before"; then
                                log_success "Time synchronized using chrony makestep (unverified sync)"
                                return 0
                            fi
                        fi
                    fi
                else
                    log_warn "Chrony burst mode failed, trying makestep directly"

                    # Try direct makestep if burst failed
                    if safe_execute 30 chronyc makestep; then
                        interruptible_sleep 5 1
                        if validate_time_sync_result "$time_before"; then
                            log_success "Time synchronized using chrony direct makestep"
                            return 0
                        fi
                    fi
                fi
            else
                log_error "Failed to restart chrony service"
            fi
        else
            log_warn "Failed to configure chrony, attempting with existing configuration"

            # Fallback to original method if configuration fails
            if safe_execute 30 chronyc makestep; then
                interruptible_sleep 5 1
                if validate_time_sync_result "$time_before"; then
                    log_success "Time synchronized using chrony (fallback method)"
                    return 0
                fi
            fi
        fi

        log_debug "chrony sync failed or insufficient correction"
    fi
                    </code_block>
                </change>
            </changes>
        </task>

        <task id="4" priority="medium">
            <name>Add retry logic with exponential backoff</name>
            <description>Create a wrapper function that implements retry logic with exponential backoff for time sync operations</description>
            <target_function>sync_with_retry()</target_function>
            <line_range>new_function</line_range>
            <changes>
                <change type="add">
                    <description>Create retry wrapper with exponential backoff</description>
                    <code_block>
# Sync time with retry logic and exponential backoff
sync_with_retry() {
    local max_attempts="${1:-3}"
    local base_delay="${2:-5}"
    local force_mode="${3:-false}"

    log_info "Starting time synchronization with retry logic"
    log_info "Max attempts: $max_attempts, Base delay: ${base_delay}s, Force mode: $force_mode"

    for ((attempt=1; attempt<=max_attempts; attempt++)); do
        log_info "Time sync attempt $attempt/$max_attempts"

        # Attempt synchronization
        if sync_system_time "$force_mode"; then
            log_success "Time synchronization successful on attempt $attempt"
            return 0
        fi

        # If not the last attempt, wait with exponential backoff
        if [[ $attempt -lt $max_attempts ]]; then
            local delay=$((base_delay * attempt))
            log_info "Attempt $attempt failed, waiting ${delay}s before retry $((attempt+1))"
            interruptible_sleep "$delay" 1

            # Force mode for subsequent attempts if first attempt failed
            force_mode="true"
        fi
    done

    log_error "Time synchronization failed after $max_attempts attempts"
    return 1
}
                    </code_block>
                </change>
            </changes>
        </task>

        <task id="5" priority="medium">
            <name>Add safe_execute_output helper function</name>
            <description>Add helper function to safely execute commands and capture output for parsing</description>
            <target_function>safe_execute_output()</target_function>
            <line_range>new_function</line_range>
            <changes>
                <change type="add">
                    <description>Create safe command execution with output capture</description>
                    <code_block>
# Execute command safely and capture output
safe_execute_output() {
    local timeout="$1"
    shift
    local cmd=("$@")

    log_debug "Executing with output capture: ${cmd[*]} (timeout: ${timeout}s)"

    local output
    local exit_code

    # Use timeout to prevent hanging
    if output=$(timeout "$timeout" "${cmd[@]}" 2>&1); then
        exit_code=0
    else
        exit_code=$?
    fi

    if [[ $exit_code -eq 0 ]]; then
        echo "$output"
        return 0
    else
        log_debug "Command failed with exit code $exit_code: ${cmd[*]}"
        log_debug "Command output: $output"
        return $exit_code
    fi
}
                    </code_block>
                </change>
            </changes>
        </task>

        <task id="6" priority="low">
            <name>Update enhanced_time_sync() to use new retry logic</name>
            <description>Modify enhanced_time_sync() function to use the new sync_with_retry() function</description>
            <target_function>enhanced_time_sync()</target_function>
            <line_range>909-975</line_range>
            <changes>
                <change type="modify">
                    <description>Replace direct sync_system_time call with retry logic</description>
                    <code_block>
    # Use retry logic for enhanced synchronization reliability
    if sync_with_retry 3 10 "$force"; then
        local final_time=$(date +%s)
        local total_correction=$((final_time - initial_time))

        log_success "=== Enhanced Time Synchronization Completed Successfully ==="
        log_info "Total time correction: ${total_correction} seconds"
        log_info "Final system time: $(date)"
        log_info "Final system time (UTC): $(date -u)"

        # Force comprehensive hardware clock sync
        if force_hwclock_sync; then
            log_debug "Hardware clock synchronized with system time"
        fi

        return 0
    else
        log_error "=== Enhanced Time Synchronization Failed ==="
        log_error "All synchronization methods failed after multiple attempts"
        log_error "System time may still be incorrect"
        return 1
    fi
                    </code_block>
                </change>
            </changes>
        </task>

        <task id="7" priority="low">
            <name>Update function exports</name>
            <description>Add new functions to the export list at the end of the file</description>
            <target_function>exports</target_function>
            <line_range>1380-1382</line_range>
            <changes>
                <change type="modify">
                    <description>Add new functions to export list</description>
                    <code_block>
export -f check_system_time_validity sync_system_time safe_apt_update detect_time_related_apt_errors force_hwclock_sync enhanced_time_sync
export -f configure_chrony_for_large_offset sync_time_from_web_api validate_time_sync_result verify_chrony_sync_status
export -f sync_with_retry safe_execute_output
                    </code_block>
                </change>
            </changes>
        </task>
    </implementation_tasks>

    <testing_approach>
        <test_category name="Unit Tests">
            <test name="test_verify_chrony_sync_status">
                <description>Test chrony synchronization status verification function</description>
                <approach>Mock chronyc tracking and sources commands with different outputs</approach>
            </test>
            <test name="test_safe_execute_output">
                <description>Test safe command execution with output capture</description>
                <approach>Test timeout handling and output parsing</approach>
            </test>
            <test name="test_sync_with_retry">
                <description>Test retry logic with exponential backoff</description>
                <approach>Mock sync_system_time to fail and verify retry behavior</approach>
            </test>
        </test_category>

        <test_category name="Integration Tests">
            <test name="test_enhanced_chrony_sync">
                <description>Test complete chrony synchronization workflow</description>
                <approach>Test with controlled time offset and verify correction</approach>
            </test>
            <test name="test_multiple_ntp_servers">
                <description>Test chrony configuration with multiple NTP servers</description>
                <approach>Verify chrony.conf generation and service restart</approach>
            </test>
        </test_category>

        <test_category name="System Tests">
            <test name="test_apt_error_resolution">
                <description>Test complete APT error resolution workflow</description>
                <approach>Create time offset scenario and verify APT update success</approach>
            </test>
        </test_category>
    </testing_approach>

    <rollback_strategy>
        <backup_plan>
            <step number="1">Create backup of original common_utils.sh before modifications</step>
            <step number="2">Store original chrony configuration in /tmp/chrony_original.conf</step>
            <step number="3">Implement configuration validation before applying changes</step>
        </backup_plan>

        <rollback_triggers>
            <trigger>Any syntax error in modified functions</trigger>
            <trigger>Chrony service fails to start with new configuration</trigger>
            <trigger>Time synchronization completely fails after changes</trigger>
            <trigger>System becomes unstable after modifications</trigger>
        </rollback_triggers>

        <rollback_steps>
            <step number="1">Stop chrony service: systemctl stop chrony</step>
            <step number="2">Restore original chrony configuration</step>
            <step number="3">Restore original common_utils.sh from backup</step>
            <step number="4">Restart chrony service: systemctl start chrony</step>
            <step number="5">Verify system functionality with original code</step>
        </rollback_steps>
    </rollback_strategy>

    <configuration_changes>
        <chrony_config>
            <description>Enhanced chrony.conf with multiple reliable NTP servers</description>
            <changes>
                <change>Add pool.ntp.org and regional NTP pools</change>
                <change>Add Google, Cloudflare, and NIST time servers</change>
                <change>Configure aggressive makestep for large offsets</change>
                <change>Enable burst mode for faster initial sync</change>
                <change>Configure proper logging and drift file</change>
            </changes>
        </chrony_config>

        <service_management>
            <description>Chrony service management improvements</description>
            <changes>
                <change>Automatic service restart after configuration changes</change>
                <change>Service status verification before operations</change>
                <change>Graceful fallback if service operations fail</change>
            </changes>
        </service_management>
    </configuration_changes>

    <validation_criteria>
        <success_criteria>
            <criterion>APT update succeeds without time-related errors</criterion>
            <criterion>Chrony shows active synchronization with Stratum 1-4 servers</criterion>
            <criterion>System time offset reduced to less than 30 seconds</criterion>
            <criterion>Time synchronization completes within 60 seconds</criterion>
            <criterion>Hardware clock is properly synchronized</criterion>
        </success_criteria>

        <performance_criteria>
            <criterion>Time sync operation completes within 2 minutes</criterion>
            <criterion>No more than 3 retry attempts needed</criterion>
            <criterion>Chrony service starts within 10 seconds</criterion>
            <criterion>NTP server response time under 5 seconds</criterion>
        </performance_criteria>
    </validation_criteria>

    <implementation_sequence>
        <phase number="1" name="Preparation">
            <action>Create backup of current common_utils.sh</action>
            <action>Validate current system state</action>
            <action>Test current time sync functionality</action>
        </phase>

        <phase number="2" name="Core Functions">
            <action>Add safe_execute_output() function (Task 5)</action>
            <action>Add verify_chrony_sync_status() function (Task 2)</action>
            <action>Add sync_with_retry() function (Task 4)</action>
        </phase>

        <phase number="3" name="Configuration Enhancement">
            <action>Enhance configure_chrony_for_large_offset() function (Task 1)</action>
            <action>Test chrony configuration generation</action>
        </phase>

        <phase number="4" name="Sync Logic Update">
            <action>Modify sync_system_time() chrony section (Task 3)</action>
            <action>Update enhanced_time_sync() function (Task 6)</action>
            <action>Update function exports (Task 7)</action>
        </phase>

        <phase number="5" name="Testing and Validation">
            <action>Run unit tests for new functions</action>
            <action>Run integration tests for sync workflow</action>
            <action>Test complete APT error resolution</action>
        </phase>
    </implementation_sequence>

    <risk_assessment>
        <risk level="high">
            <description>Chrony service failure could break system time completely</description>
            <mitigation>Maintain fallback to original method and web API sync</mitigation>
        </risk>

        <risk level="medium">
            <description>Extended wait times could slow down installation process</description>
            <mitigation>Implement configurable timeouts and parallel operations where possible</mitigation>
        </risk>

        <risk level="low">
            <description>New NTP servers might be unreachable in some networks</description>
            <mitigation>Use diverse set of servers including regional pools</mitigation>
        </risk>
    </risk_assessment>
</implementation_plan>