<?xml version="1.0" encoding="UTF-8"?>
<implementation_plan>
  <project>VLESS+Reality VPN Service</project>
  <stage>Stage 2: Configuration Generation</stage>
  <date>2025-01-25</date>
  <version>1.0</version>

  <overview>
    <description>Implement configuration generation functions for VLESS+Reality VPN service</description>
    <goal>Add cryptographic key generation, UUID creation, and configuration file generation to vless-manager.sh</goal>
    <integration_point>Insert new functions after environment configuration and before installation completion</integration_point>
    <dependencies>
      <dependency>Docker with teddysun/xray image for X25519 key generation</dependency>
      <dependency>uuidgen utility or /proc/sys/kernel/random/uuid</dependency>
      <dependency>/dev/urandom for secure random generation</dependency>
      <dependency>Existing vless-manager.sh infrastructure</dependency>
    </dependencies>
  </overview>

  <implementation_tasks>

    <!-- Task 1: X25519 Key Generation Function -->
    <task id="1" priority="high">
      <name>implement_generate_keys_function</name>
      <description>Create generate_keys() function for X25519 key pair generation</description>
      <location>vless-manager.sh, line ~428 (after create_env_file function)</location>
      <implementation_steps>
        <step order="1">
          <action>Add function header with documentation</action>
          <details>Include purpose, parameters, return values, and error conditions</details>
        </step>
        <step order="2">
          <action>Implement Docker-based key generation</action>
          <details>Use 'docker run --rm teddysun/xray x25519' command to generate key pair</details>
        </step>
        <step order="3">
          <action>Parse and validate key output</action>
          <details>Extract privateKey and publicKey from command output using regex</details>
        </step>
        <step order="4">
          <action>Store keys securely</action>
          <details>Save to data/keys/private.key and data/keys/public.key with 600 permissions</details>
        </step>
        <step order="5">
          <action>Add comprehensive error handling</action>
          <details>Handle Docker unavailable, image pull failures, parsing errors, file write failures</details>
        </step>
        <step order="6">
          <action>Add logging and status messages</action>
          <details>Log start, progress, success, and error states with appropriate colors</details>
        </step>
      </implementation_steps>
      <error_handling>
        <scenario>Docker not available</scenario>
        <solution>Check docker command existence and daemon status before execution</solution>
        <scenario>Xray image not found</scenario>
        <solution>Attempt to pull image, provide fallback instructions</solution>
        <scenario>Key parsing failure</scenario>
        <solution>Validate output format, provide detailed error message</solution>
        <scenario>File write permission denied</scenario>
        <solution>Verify directory permissions, provide path fix suggestions</solution>
      </error_handling>
      <testing>
        <unit_test>Test successful key generation with mocked Docker output</unit_test>
        <unit_test>Test error handling for missing Docker</unit_test>
        <unit_test>Test error handling for malformed key output</unit_test>
        <unit_test>Test file permission setting</unit_test>
        <integration_test>Test with real Docker environment</integration_test>
      </testing>
    </task>

    <!-- Task 2: UUID Generation Function -->
    <task id="2" priority="medium">
      <name>implement_generate_uuid_function</name>
      <description>Create generate_uuid() function for UUID v4 generation</description>
      <location>vless-manager.sh, line ~480 (after generate_keys function)</location>
      <implementation_steps>
        <step order="1">
          <action>Add function header with documentation</action>
          <details>Include purpose, return format, and fallback mechanisms</details>
        </step>
        <step order="2">
          <action>Implement primary UUID generation method</action>
          <details>Use 'uuidgen' command if available</details>
        </step>
        <step order="3">
          <action>Implement fallback UUID generation</action>
          <details>Use /proc/sys/kernel/random/uuid or custom generation from /dev/urandom</details>
        </step>
        <step order="4">
          <action>Validate UUID format</action>
          <details>Ensure output matches UUID v4 format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx</details>
        </step>
        <step order="5">
          <action>Add error handling and logging</action>
          <details>Handle all generation method failures, provide informative messages</details>
        </step>
      </implementation_steps>
      <error_handling>
        <scenario>uuidgen command not found</scenario>
        <solution>Fall back to /proc/sys/kernel/random/uuid</solution>
        <scenario>/proc/sys/kernel/random/uuid not available</scenario>
        <solution>Generate UUID manually using /dev/urandom and proper formatting</solution>
        <scenario>Invalid UUID format generated</scenario>
        <solution>Validate format and regenerate if necessary</solution>
      </error_handling>
      <testing>
        <unit_test>Test UUID format validation</unit_test>
        <unit_test>Test fallback mechanisms</unit_test>
        <unit_test>Test with mocked system conditions</unit_test>
        <integration_test>Test UUID uniqueness across multiple calls</integration_test>
      </testing>
    </task>

    <!-- Task 3: ShortId Generation Function -->
    <task id="3" priority="medium">
      <name>implement_generate_short_id_function</name>
      <description>Create generate_short_id() function for hexadecimal shortId generation</description>
      <location>vless-manager.sh, line ~520 (after generate_uuid function)</location>
      <implementation_steps>
        <step order="1">
          <action>Add function header with documentation</action>
          <details>Include purpose, length parameter (optional, default 8), format specification</details>
        </step>
        <step order="2">
          <action>Implement parameter validation</action>
          <details>Ensure length is even number between 2 and 16</details>
        </step>
        <step order="3">
          <action>Generate random hexadecimal string</action>
          <details>Use /dev/urandom with hexdump or dd/od to create hex string</details>
        </step>
        <step order="4">
          <action>Format and validate output</action>
          <details>Ensure lowercase hexadecimal characters only (0-9, a-f)</details>
        </step>
        <step order="5">
          <action>Add error handling and logging</action>
          <details>Handle /dev/urandom access issues, invalid parameters</details>
        </step>
      </implementation_steps>
      <error_handling>
        <scenario>Invalid length parameter</scenario>
        <solution>Validate input, provide usage message, default to 8</solution>
        <scenario>/dev/urandom access denied</scenario>
        <solution>Check permissions, suggest running as root</solution>
        <scenario>Hexadecimal conversion failure</scenario>
        <solution>Retry generation, provide fallback method</solution>
      </error_handling>
      <testing>
        <unit_test>Test various length parameters</unit_test>
        <unit_test>Test invalid parameter handling</unit_test>
        <unit_test>Test output format validation</unit_test>
        <integration_test>Test randomness and uniqueness</integration_test>
      </testing>
    </task>

    <!-- Task 4: Server Configuration Generation Function -->
    <task id="4" priority="high">
      <name>implement_create_server_config_function</name>
      <description>Create create_server_config() function to generate Xray server JSON configuration</description>
      <location>vless-manager.sh, line ~560 (after generate_short_id function)</location>
      <implementation_steps>
        <step order="1">
          <action>Add function header with comprehensive documentation</action>
          <details>Include purpose, required parameters, configuration structure</details>
        </step>
        <step order="2">
          <action>Load environment variables and keys</action>
          <details>Source .env file, read private key from data/keys/private.key</details>
        </step>
        <step order="3">
          <action>Generate shortIds array</action>
          <details>Create multiple shortIds including empty string, random 8 and 16 char ids</details>
        </step>
        <step order="4">
          <action>Create JSON configuration structure</action>
          <details>Build complete Xray server config with VLESS inbound and Reality transport</details>
        </step>
        <step order="5">
          <action>Write configuration to file</action>
          <details>Save to config/server.json with 600 permissions</details>
        </step>
        <step order="6">
          <action>Validate JSON format</action>
          <details>Use python -m json.tool or jq to validate syntax</details>
        </step>
        <step order="7">
          <action>Add comprehensive logging</action>
          <details>Log configuration generation steps and final validation</details>
        </step>
      </implementation_steps>
      <configuration_template>
        <json_structure>
          <log>
            <level>${LOG_LEVEL}</level>
            <output>${LOG_FILE}</output>
          </log>
          <inbounds>
            <protocol>vless</protocol>
            <port>${XRAY_PORT}</port>
            <settings>
              <clients>
                <id>${ADMIN_UUID}</id>
              </clients>
              <decryption>none</decryption>
            </settings>
            <streamSettings>
              <network>tcp</network>
              <security>reality</security>
              <realitySettings>
                <dest>${REALITY_DEST}</dest>
                <serverNames>${REALITY_SERVER_NAMES}</serverNames>
                <privateKey>${PRIVATE_KEY}</privateKey>
                <shortIds>${SHORT_IDS_ARRAY}</shortIds>
              </realitySettings>
            </streamSettings>
          </inbounds>
        </json_structure>
      </configuration_template>
      <error_handling>
        <scenario>Missing environment variables</scenario>
        <solution>Check .env file existence and required variables, provide detailed error</solution>
        <scenario>Private key file not found</scenario>
        <solution>Check if generate_keys() was called, provide recovery instructions</solution>
        <scenario>JSON validation failure</scenario>
        <solution>Check configuration structure, provide syntax error details</solution>
        <scenario>File write permission denied</scenario>
        <solution>Verify config directory permissions, run with proper privileges</solution>
      </error_handling>
      <testing>
        <unit_test>Test JSON structure generation</unit_test>
        <unit_test>Test environment variable substitution</unit_test>
        <unit_test>Test error handling for missing dependencies</unit_test>
        <integration_test>Test complete configuration generation flow</integration_test>
        <validation_test>Validate generated JSON against Xray schema</validation_test>
      </testing>
    </task>

    <!-- Task 5: Docker Compose Configuration Function -->
    <task id="5" priority="high">
      <name>implement_create_docker_compose_function</name>
      <description>Create create_docker_compose() function to generate Docker Compose YAML</description>
      <location>vless-manager.sh, line ~650 (after create_server_config function)</location>
      <implementation_steps>
        <step order="1">
          <action>Add function header with documentation</action>
          <details>Include purpose, dependencies, generated file structure</details>
        </step>
        <step order="2">
          <action>Load environment variables</action>
          <details>Source .env file for Docker image, ports, and paths</details>
        </step>
        <step order="3">
          <action>Generate Docker Compose YAML structure</action>
          <details>Create service definition with proper volumes, ports, and restart policy</details>
        </step>
        <step order="4">
          <action>Configure volume mounts</action>
          <details>Mount config, data, and logs directories with proper permissions</details>
        </step>
        <step order="5">
          <action>Set resource limits and policies</action>
          <details>Configure restart policy, resource limits, network settings</details>
        </step>
        <step order="6">
          <action>Write YAML file</action>
          <details>Save to docker-compose.yml with 644 permissions</details>
        </step>
        <step order="7">
          <action>Validate YAML syntax</action>
          <details>Use docker compose config to validate generated file</details>
        </step>
      </implementation_steps>
      <yaml_template>
        <structure>
          <version>3.8</version>
          <services>
            <xray>
              <image>${DOCKER_IMAGE}</image>
              <container_name>vless-xray</container_name>
              <restart>unless-stopped</restart>
              <ports>
                <mapping>${XRAY_PORT}:443</mapping>
              </ports>
              <volumes>
                <config_mount>./config:/etc/xray:ro</config_mount>
                <data_mount>./data:/app/data:rw</data_mount>
                <logs_mount>./logs:/app/logs:rw</logs_mount>
              </volumes>
              <environment>
                <compose_project>${COMPOSE_PROJECT_NAME}</compose_project>
              </environment>
              <networks>
                <network>vless-network</network>
              </networks>
            </xray>
          </services>
          <networks>
            <vless_network>
              <driver>bridge</driver>
            </vless_network>
          </networks>
        </structure>
      </yaml_template>
      <error_handling>
        <scenario>Environment variables missing</scenario>
        <solution>Validate .env file completeness, provide missing variable list</solution>
        <scenario>YAML syntax errors</scenario>
        <solution>Validate indentation and structure, provide line-specific errors</solution>
        <scenario>Docker Compose validation failure</scenario>
        <solution>Run docker compose config and display validation errors</solution>
        <scenario>Port conflicts</scenario>
        <solution>Check port availability before generating configuration</solution>
      </error_handling>
      <testing>
        <unit_test>Test YAML structure generation</unit_test>
        <unit_test>Test environment variable substitution</unit_test>
        <unit_test>Test error handling for invalid configurations</unit_test>
        <integration_test>Test Docker Compose file validation</integration_test>
        <system_test>Test Docker Compose up with generated file</system_test>
      </testing>
    </task>

    <!-- Task 6: Integration with Main Installation Flow -->
    <task id="6" priority="critical">
      <name>integrate_configuration_functions</name>
      <description>Integrate configuration generation functions into main installation flow</description>
      <location>vless-manager.sh, install_service function, line ~555 (after Step 5)</location>
      <implementation_steps>
        <step order="1">
          <action>Add Step 6: Generate X25519 Keys</action>
          <details>Insert call to generate_keys() with proper error handling</details>
        </step>
        <step order="2">
          <action>Add Step 7: Create Server Configuration</action>
          <details>Insert call to create_server_config() with dependency checks</details>
        </step>
        <step order="3">
          <action>Add Step 8: Create Docker Compose Configuration</action>
          <details>Insert call to create_docker_compose() with validation</details>
        </step>
        <step order="4">
          <action>Update progress indicators</action>
          <details>Change step numbering from [1/5] to [1/8] format throughout</details>
        </step>
        <step order="5">
          <action>Update installation summary</action>
          <details>Add configuration generation items to success summary</details>
        </step>
        <step order="6">
          <action>Update next steps guidance</action>
          <details>Modify next steps to reflect completed configuration</details>
        </step>
      </implementation_steps>
      <error_handling>
        <scenario>Configuration generation failure</scenario>
        <solution>Halt installation, provide rollback instructions</solution>
        <scenario>Partial configuration state</scenario>
        <solution>Clean up partial files, maintain installation consistency</solution>
      </error_handling>
      <testing>
        <integration_test>Test complete installation flow with all steps</integration_test>
        <integration_test>Test error handling and rollback scenarios</integration_test>
        <system_test>Verify installation produces working configuration</system_test>
      </testing>
    </task>

    <!-- Task 7: Error Handling Enhancement -->
    <task id="7" priority="medium">
      <name>enhance_error_handling_framework</name>
      <description>Enhance existing error handling framework for configuration functions</description>
      <location>vless-manager.sh, handle_error function area, line ~71</location>
      <implementation_steps>
        <step order="1">
          <action>Add configuration-specific error codes</action>
          <details>Define error codes for key generation, config creation, validation failures</details>
        </step>
        <step order="2">
          <action>Implement cleanup function</action>
          <details>Create cleanup_partial_config() to remove partial configuration files</details>
        </step>
        <step order="3">
          <action>Add rollback mechanisms</action>
          <details>Implement rollback for each configuration step</details>
        </step>
        <step order="4">
          <action>Enhance error reporting</action>
          <details>Provide detailed error messages with recovery suggestions</details>
        </step>
      </implementation_steps>
      <error_codes>
        <code value="10">KEY_GENERATION_FAILED</code>
        <code value="11">UUID_GENERATION_FAILED</code>
        <code value="12">CONFIG_CREATION_FAILED</code>
        <code value="13">DOCKER_COMPOSE_FAILED</code>
        <code value="14">VALIDATION_FAILED</code>
      </error_codes>
    </task>

  </implementation_tasks>

  <implementation_order>
    <phase name="Foundation" order="1">
      <task_ref>1</task_ref> <!-- generate_keys function -->
      <task_ref>2</task_ref> <!-- generate_uuid function -->
      <task_ref>3</task_ref> <!-- generate_short_id function -->
      <rationale>Core generation functions must be implemented first as dependencies</rationale>
    </phase>

    <phase name="Configuration" order="2">
      <task_ref>4</task_ref> <!-- create_server_config function -->
      <task_ref>5</task_ref> <!-- create_docker_compose function -->
      <rationale>Configuration functions depend on generation functions</rationale>
    </phase>

    <phase name="Integration" order="3">
      <task_ref>7</task_ref> <!-- enhance_error_handling_framework -->
      <task_ref>6</task_ref> <!-- integrate_configuration_functions -->
      <rationale>Error handling must be enhanced before integration to ensure robustness</rationale>
    </phase>
  </implementation_order>

  <testing_strategy>
    <unit_testing>
      <description>Test individual functions in isolation</description>
      <location>tests/test_vless_manager.sh</location>
      <requirements>
        <requirement>Mock external dependencies (Docker, system files)</requirement>
        <requirement>Test all error conditions and edge cases</requirement>
        <requirement>Validate output formats and file permissions</requirement>
        <requirement>Test parameter validation and input sanitization</requirement>
      </requirements>
    </unit_testing>

    <integration_testing>
      <description>Test functions working together in realistic scenarios</description>
      <location>tests/test_configuration.sh (new file)</location>
      <requirements>
        <requirement>Test complete configuration generation flow</requirement>
        <requirement>Validate configuration file relationships</requirement>
        <requirement>Test error propagation and rollback mechanisms</requirement>
        <requirement>Verify Docker Compose functionality</requirement>
      </requirements>
    </integration_testing>

    <system_testing>
      <description>Test configuration with actual Xray service</description>
      <location>tests/test_system_integration.sh (new file)</location>
      <requirements>
        <requirement>Test generated configuration with real Docker environment</requirement>
        <requirement>Validate Xray service startup with generated config</requirement>
        <requirement>Test configuration validation tools</requirement>
        <requirement>Verify network connectivity and service functionality</requirement>
      </requirements>
    </system_testing>

    <security_testing>
      <description>Validate security aspects of generated configurations</description>
      <requirements>
        <requirement>Verify file permissions on sensitive files</requirement>
        <requirement>Test key generation randomness and strength</requirement>
        <requirement>Validate no secrets in logs or temporary files</requirement>
        <requirement>Test configuration sanitization</requirement>
      </requirements>
    </security_testing>
  </testing_strategy>

  <validation_criteria>
    <functional_requirements>
      <requirement>X25519 key pair generated and stored securely</requirement>
      <requirement>Valid UUID v4 generated for admin user</requirement>
      <requirement>Hexadecimal shortIds generated with correct format</requirement>
      <requirement>Xray server configuration valid and complete</requirement>
      <requirement>Docker Compose configuration functional</requirement>
      <requirement>All functions integrated into installation flow</requirement>
    </functional_requirements>

    <security_requirements>
      <requirement>Private keys stored with 600 permissions</requirement>
      <requirement>Configuration files secured appropriately</requirement>
      <requirement>No hardcoded secrets or credentials</requirement>
      <requirement>Secure random generation for all cryptographic material</requirement>
    </security_requirements>

    <quality_requirements>
      <requirement>All functions have comprehensive error handling</requirement>
      <requirement>Logging provides clear status and error information</requirement>
      <requirement>Code follows established style and patterns</requirement>
      <requirement>All test suites pass successfully</requirement>
      <requirement>Configuration files validate against schemas</requirement>
    </quality_requirements>
  </validation_criteria>

  <deliverables>
    <file name="vless-manager.sh">
      <description>Updated main script with configuration generation functions</description>
      <changes>
        <change>Added generate_keys() function</change>
        <change>Added generate_uuid() function</change>
        <change>Added generate_short_id() function</change>
        <change>Added create_server_config() function</change>
        <change>Added create_docker_compose() function</change>
        <change>Enhanced error handling framework</change>
        <change>Integrated functions into installation flow</change>
        <change>Updated help and progress indicators</change>
      </changes>
    </file>

    <file name="config/server.json">
      <description>Generated Xray server configuration</description>
      <generated_by>create_server_config() function</generated_by>
      <permissions>600</permissions>
    </file>

    <file name="docker-compose.yml">
      <description>Generated Docker Compose configuration</description>
      <generated_by>create_docker_compose() function</generated_by>
      <permissions>644</permissions>
    </file>

    <file name="data/keys/private.key">
      <description>X25519 private key for Reality transport</description>
      <generated_by>generate_keys() function</generated_by>
      <permissions>600</permissions>
    </file>

    <file name="data/keys/public.key">
      <description>X25519 public key for client configurations</description>
      <generated_by>generate_keys() function</generated_by>
      <permissions>600</permissions>
    </file>

    <file name="tests/test_configuration.sh">
      <description>Integration tests for configuration generation</description>
      <purpose>Validate configuration generation workflow</purpose>
      <permissions>755</permissions>
    </file>
  </deliverables>

  <risk_mitigation>
    <risk level="high">
      <description>Docker unavailable during key generation</description>
      <mitigation>Check Docker availability, provide installation instructions</mitigation>
      <fallback>Provide manual key generation instructions</fallback>
    </risk>

    <risk level="medium">
      <description>Network connectivity issues during Docker image pull</description>
      <mitigation>Check connectivity, provide offline alternatives</mitigation>
      <fallback>Use pre-downloaded image or manual installation</fallback>
    </risk>

    <risk level="medium">
      <description>Insufficient permissions for file operations</description>
      <mitigation>Verify permissions before operations, provide clear error messages</mitigation>
      <fallback>Guide user to run with proper privileges</fallback>
    </risk>

    <risk level="low">
      <description>Configuration validation failures</description>
      <mitigation>Implement robust validation, provide detailed error information</mitigation>
      <fallback>Provide manual configuration templates</fallback>
    </risk>
  </risk_mitigation>

  <success_metrics>
    <metric>All configuration generation functions implemented and functional</metric>
    <metric>Complete integration with existing installation workflow</metric>
    <metric>All test suites passing (unit, integration, system)</metric>
    <metric>Generated configurations validate successfully</metric>
    <metric>Docker Compose service starts successfully with generated config</metric>
    <metric>Proper file permissions and security measures implemented</metric>
    <metric>Comprehensive error handling and user guidance</metric>
  </success_metrics>

  <next_stage_preparation>
    <stage_3_requirements>
      <requirement>User management functions will use generated UUIDs</requirement>
      <requirement>Client configurations will use public key from generated pair</requirement>
      <requirement>User database will reference generated server configuration</requirement>
    </stage_3_requirements>

    <stage_4_requirements>
      <requirement>Docker Compose configuration must be functional for service startup</requirement>
      <requirement>Generated server configuration must be valid for Xray service</requirement>
      <requirement>Network and volume mounts must be properly configured</requirement>
    </stage_4_requirements>
  </next_stage_preparation>

</implementation_plan>