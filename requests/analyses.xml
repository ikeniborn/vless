<?xml version="1.0" encoding="UTF-8"?>
<analysis>
  <project>VLESS+Reality VPN Service</project>
  <stage>Stage 2: Configuration Generation</stage>
  <date>2025-01-25</date>

  <requirements>
    <requirement id="1">
      <description>Generate X25519 key pairs (privateKey/publicKey)</description>
      <technical_details>
        <detail>X25519 is an elliptic curve Diffie-Hellman key exchange mechanism</detail>
        <detail>Keys are 32 bytes (256 bits) long</detail>
        <detail>Generated using xray x25519 command</detail>
        <detail>privateKey stays on server, publicKey shared with clients</detail>
      </technical_details>
      <implementation>Use docker run with xray image to execute x25519 command</implementation>
    </requirement>

    <requirement id="2">
      <description>Generate UUID for users</description>
      <technical_details>
        <detail>UUID v4 format required (e.g., 550e8400-e29b-41d4-a716-446655440000)</detail>
        <detail>Unique identifier for each VLESS user</detail>
        <detail>Stored in users.db file</detail>
      </technical_details>
      <implementation>Use uuidgen command or /proc/sys/kernel/random/uuid</implementation>
    </requirement>

    <requirement id="3">
      <description>Generate shortIds for REALITY</description>
      <technical_details>
        <detail>Characters: 0-9 and a-f (hexadecimal)</detail>
        <detail>Length: multiple of 2, maximum 16 characters</detail>
        <detail>Can include empty shortId</detail>
        <detail>Used to distinguish different clients</detail>
      </technical_details>
      <implementation>Generate random hex strings using /dev/urandom</implementation>
    </requirement>

    <requirement id="4">
      <description>Create Xray server configuration</description>
      <technical_details>
        <detail>JSON format at config/server.json</detail>
        <detail>VLESS protocol with REALITY transport</detail>
        <detail>Minimal logging (warning level)</detail>
        <detail>Port 443 for VLESS+Reality</detail>
        <detail>Destination: speed.cloudflare.com:443</detail>
      </technical_details>
      <implementation>Generate JSON config with dynamic values from previous steps</implementation>
    </requirement>

    <requirement id="5">
      <description>Create Docker Compose configuration</description>
      <technical_details>
        <detail>Image: teddysun/xray:latest</detail>
        <detail>Port mapping: 443:443</detail>
        <detail>Volume mounts: config, logs, data</detail>
        <detail>Restart policy: unless-stopped</detail>
      </technical_details>
      <implementation>Generate docker-compose.yml with proper structure</implementation>
    </requirement>
  </requirements>

  <functions_to_implement>
    <function name="generate_keys">
      <purpose>Generate X25519 key pair for REALITY transport</purpose>
      <inputs>None</inputs>
      <outputs>privateKey and publicKey stored in data/keys/</outputs>
      <error_handling>Check Docker availability, handle generation failures</error_handling>
    </function>

    <function name="generate_uuid">
      <purpose>Create UUID v4 for user identification</purpose>
      <inputs>None</inputs>
      <outputs>UUID string in standard format</outputs>
      <error_handling>Fallback to /dev/urandom if uuidgen unavailable</error_handling>
    </function>

    <function name="generate_short_id">
      <purpose>Generate random hexadecimal shortId</purpose>
      <inputs>Length (optional, default 8)</inputs>
      <outputs>Hexadecimal string of specified length</outputs>
      <error_handling>Validate length is even and <= 16</error_handling>
    </function>

    <function name="create_server_config">
      <purpose>Generate Xray server JSON configuration</purpose>
      <inputs>privateKey, shortIds array</inputs>
      <outputs>config/server.json file</outputs>
      <error_handling>Validate JSON format, check file permissions</error_handling>
    </function>

    <function name="create_docker_compose">
      <purpose>Generate Docker Compose configuration</purpose>
      <inputs>Environment variables from .env</inputs>
      <outputs>docker-compose.yml file</outputs>
      <error_handling>Validate YAML format, check port availability</error_handling>
    </function>
  </functions_to_implement>

  <integration_points>
    <integration>
      <location>install command in vless-manager.sh</location>
      <description>Call configuration functions after directory creation</description>
      <order>After create_directories(), before completion message</order>
    </integration>

    <integration>
      <location>Environment variables</location>
      <description>Use existing .env file for configuration values</description>
      <variables>PROJECT_PATH, SERVER_IP, XRAY_PORT, LOG_LEVEL</variables>
    </integration>
  </integration_points>

  <security_considerations>
    <consideration>Store keys with 600 permissions in data/keys/</consideration>
    <consideration>Config files accessible only by root (600 permissions)</consideration>
    <consideration>No hardcoded secrets in scripts</consideration>
    <consideration>Validate all user inputs</consideration>
    <consideration>Use secure random generation for keys and IDs</consideration>
  </security_considerations>

  <testing_requirements>
    <test>Unit test for each generation function</test>
    <test>Validate JSON configuration format</test>
    <test>Check file permissions after creation</test>
    <test>Test error handling for missing dependencies</test>
    <test>Integration test for full configuration flow</test>
  </testing_requirements>

  <dependencies>
    <dependency>Docker with xray image for key generation</dependency>
    <dependency>uuidgen or /proc/sys/kernel/random/uuid</dependency>
    <dependency>/dev/urandom for random generation</dependency>
    <dependency>jq for JSON manipulation (optional)</dependency>
  </dependencies>

  <success_criteria>
    <criterion>All configuration files generated correctly</criterion>
    <criterion>Proper file permissions set</criterion>
    <criterion>Functions integrated into install workflow</criterion>
    <criterion>Error handling prevents partial states</criterion>
    <criterion>All tests passing</criterion>
  </success_criteria>
</analysis>